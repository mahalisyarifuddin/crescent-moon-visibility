<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MABBIMS Hijri Calendar</title>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--highlight-bg: #d4e3ff;
			--formula-bg: #f8f9fa;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
				--formula-bg: #1e222b;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--highlight-bg: #001c3a;
			--formula-bg: #1e222b;
		}
		* { 
			box-sizing: border-box; 
			margin: 0; 
			padding: 0; 
			outline-offset: 2px; 
		}
		*:focus-visible { 
			outline: 2px solid var(--primary); 
		}
		body {
			font-family: sans-serif;
			background-color: var(--background);
			color: var(--text);
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 960px;
			width: 100%;
			padding: 2rem;
			position: relative;
			margin: 2rem 0;
			box-shadow: 0 4px 15px rgba(0,0,0,0.05);
		}
		h1, h2, h3, label { 
			margin: .5rem 0; 
		}
		label { 
			display: block; 
			font-weight: 700; 
			margin-bottom: 0.25rem; 
			font-size: 0.9rem; 
		}
		input, select, button {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font-size: 1rem;
			padding: .5rem;
			width: 100%;
		}
		button { 
			cursor: pointer; 
			font-weight: 500; 
			transition: background 0.2s; 
		}
		button:hover { 
			opacity: 0.9; 
		}
		button:disabled { 
			opacity: 0.6; 
			cursor: not-allowed; 
		}
		.primary { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
		}
		.primary:hover:not(:disabled) { 
			background: var(--hover); 
		}
		.secondary { 
			background: transparent; 
			border: 1px solid var(--border); 
			color: var(--text); 
		}
		.secondary:hover:not(:disabled) { 
			background: var(--muted); 
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
		}
		.calendar-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1.5rem;
			flex-wrap: wrap;
			gap: 10px;
		}
		.calendar-grid {
			display: grid;
			grid-template-columns: repeat(7, minmax(50px, 1fr));
			gap: 1px;
			background: var(--border);
			border: 1px solid var(--border);
			border-radius: 4px;
			overflow-x: auto;
			min-width: 100%;
		}
		.day-header {
			background: var(--muted);
			padding: 10px;
			text-align: center;
			font-weight: bold;
			font-size: 0.9rem;
		}
		.day-cell {
			background: var(--surface);
			min-height: 100px;
			padding: 8px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			position: relative;
			overflow: hidden;
		}
		.day-cell.other-month { 
			opacity: 0.5; 
			background: var(--formula-bg); 
		}
		.day-cell.today { 
			background: var(--highlight-bg); 
		}
		.day-cell.selected { 
			border: 2px solid var(--primary); 
		}
		.day-cell:hover { 
			background: var(--muted); 
			cursor: pointer; 
		}
		.day-cell:focus { 
			outline: 2px solid var(--primary); 
			z-index: 10; 
		}
		.gregorian-date { 
			font-size: 1.2rem; 
			font-weight: 700; 
			order: 1; 
		}
		.hijri-wrapper { 
			order: 2; 
			text-align: right; 
		}
		.hijri-date { 
			font-size: 0.9rem; 
			color: var(--primary); 
			font-weight: 600; 
		}
		.hijri-month-name { 
			font-size: 0.75rem; 
			opacity: 0.8; 
		}
		.calendar-grid.hijri-primary .gregorian-date {
			order: 2;
			font-size: 0.9rem;
			font-weight: 600;
			text-align: right;
			color: var(--primary);
			align-self: flex-end;
			width: 100%;
		}
		.calendar-grid.hijri-primary .hijri-wrapper { 
			order: 1; 
			text-align: left; 
		}
		.calendar-grid.hijri-primary .hijri-date { 
			font-size: 1.2rem; 
			font-weight: 700; 
			color: var(--text); 
			text-align: left; 
		}
		.calendar-grid.hijri-primary .hijri-month-name { 
			text-align: left; 
		}
		.controls { 
			display: flex; 
			justify-content: center;
			margin-bottom: 1.5rem;
		}
		.control-group {
			width: 100%;
			max-width: 700px;
			background: var(--formula-bg);
			padding: 1.5rem;
			border-radius: 8px;
			border: 1px solid var(--border);
		}
		.row { 
			display: flex; 
			gap: 0.5rem; 
			margin-bottom: 0.5rem; 
		}
		.row > * { 
			flex: 1; 
		}
		dialog {
			background: var(--surface);
			color: var(--text);
			border: 1px solid var(--border);
			border-radius: 8px;
			padding: 1.5rem;
			max-width: 400px;
			width: 100%;
			margin: auto;
			position: fixed;
		}
		dialog::backdrop { 
			background: rgba(0, 0, 0, 0.5); 
		}
		.dialog-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1.5rem;
		}
		.dialog-header h3 { 
			font-size: 1.25rem; 
			font-weight: 600; 
			margin: 0; 
		}
		.close-button {
			background: transparent;
			color: var(--text);
			padding: .25rem;
			font-size: 1.5rem;
			line-height: 1;
			border: none;
			width: auto;
		}
		.close-button:hover { 
			background: var(--background); 
			color: var(--text); 
		}
		.group {
			background: var(--background);
			border: 1px solid var(--border);
			padding: 1rem;
			border-radius: 6px;
			margin-bottom: 1rem;
			position: relative;
		}
		dialog input:not([type=color]):not([type=range]), dialog textarea, dialog select, dialog button {
			width: 100%;
			padding: .5rem .75rem;
			border: 1px solid var(--border);
			border-radius: 4px;
			background: var(--surface);
			color: var(--text);
			margin-top: 4px;
			font-family: inherit;
			font-size: .95rem;
		}
		dialog button { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
			cursor: pointer; 
		}
		dialog button:hover { 
			background: var(--hover); 
		}
		.info-text { 
			font-size: 0.85rem; 
			opacity: 0.7; 
			margin-top: 1rem; 
			text-align: center; 
		}
		@media(max-width: 600px) {
			.selectors { 
				position: static; 
				justify-content: 
				flex-end; 
				margin-bottom: 1rem; 
			}
			.calendar-header { 
				flex-direction: row;
				align-items: center;
				flex-wrap: nowrap;
				gap: 5px;
			}
			.calendar-header h2 {
				font-size: 1.1rem;
				flex: 1;
				text-align: center;
				margin: 0;
				white-space: nowrap;
			}
			.day-cell { 
				min-height: 60px; 
				padding: 4px; 
			}
			.gregorian-date { 
				font-size: 1rem; 
			}
			.hijri-date { 
				font-size: 0.8rem; 
			}
			.calendar-grid.hijri-primary .hijri-date { 
				font-size: 1rem; 
			}
			.calendar-grid.hijri-primary .gregorian-date { 
				font-size: 0.8rem; 
			}
		}
		.spinner {
			display: inline-block;
			width: 1em;
			height: 1em;
			border: 2px solid currentColor;
			border-right-color: transparent;
			border-radius: 50%;
			animation: spin 0.75s linear infinite;
			vertical-align: text-bottom;
			margin-right: 4px;
		}
		@keyframes spin { 
			100% { 
				transform: rotate(360deg); 
			} 
		}
		.nav-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1rem;
		}
		.small-btn {
			width: auto;
			padding: 6px 12px;
			font-size: 0.9rem;
		}
		.input-group {
			display: flex;
			gap: 0.5rem;
			margin-bottom: 1rem;
			align-items: center;
		}
		.input-group > * {
			flex: 1;
		}
		.sr-only {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0,0,0,0);
			border: 0;
		}
		#hDayInput {
			flex: 0.6;
		}
		#hMonthInput {
			flex: 2;
		}
		#hYearInput {
			flex: 1;
		}
		#goHBtn {
			flex: 0.4;
			min-width: 40px;
			padding: 0.5rem;
			font-weight: bold;
		}
		details {
			margin-top: 2rem;
			border-top: 1px solid var(--border);
			padding-top: 1rem;
		}
		summary {
			cursor: pointer;
			opacity: 0.8;
			font-size: 0.9rem;
			margin-bottom: 0.5rem;
		}
		summary:hover {
			opacity: 1;
			color: var(--primary);
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="selectors">
			<button id="prefBtn" class="secondary" style="width:auto; padding: 6px 12px;" data-i18n="prefTitle"></button>
		</div>
		<h1 id="appTitle" data-i18n="appTitle"></h1>
		<p id="appSubtitle" style="opacity: 0.7; margin-bottom: 2rem;"></p>
		<div class="controls">
			<div class="control-group">
				<label class="sr-only" data-i18n="gDateLabel"></label>
				<div class="input-group">
					<input type="date" id="gDateInput" data-i18n-aria="gDateLabel">
					<button id="todayBtn" class="secondary" data-i18n="today" style="flex:0.3"></button>
				</div>
				<div class="input-group" style="margin-bottom:0">
					<input type="number" id="hDayInput" placeholder="D" min="1" max="30" data-i18n-aria="hDayLabel">
					<select id="hMonthInput" data-i18n-aria="hMonthLabel"></select>
					<input type="number" id="hYearInput" placeholder="Year" min="1300" max="2500" data-i18n-aria="hYearLabel" data-i18n-placeholder="yearPlaceholder">
					<button id="goHBtn" class="primary" aria-label="Go to Hijri Date" data-i18n-aria="goHBtnLabel">&rarr;</button>
				</div>
			</div>
		</div>
		<div class="calendar-header">
			<button id="prevMonthBtn" class="secondary" style="width: auto;" data-i18n="prevBtn" data-i18n-aria="prevMonthLabel"></button>
			<h2 id="monthDisplay"></h2>
			<button id="nextMonthBtn" class="secondary" style="width: auto;" data-i18n="nextBtn" data-i18n-aria="nextMonthLabel"></button>
		</div>
		<div class="calendar-grid" id="calendar"></div>
		<details>
			<summary><span data-i18n="formulaTitle"></span></summary>
			<p style="font-family: monospace; font-size: 0.9rem; background: var(--surface); padding: 5px; border: 1px solid var(--border); border-radius: 4px; margin-bottom: 5px;">JD = 1948440 + 354(H-1) + floor((11(H-1) + 11) / 30)</p>
			<p id="formulaDesc" style="font-size: 0.8rem; opacity: 0.8;" data-i18n="formulaDesc"></p>
			<p style="font-size: 0.8rem; opacity: 0.8; margin-top:5px;"><i>Optimized Tabular (Arafah). Verified matches MABBIMS visibility (1300-1600 AH) at Arafah, Mecca.</i></p>
			<p class="info-text" id="footerNote" data-i18n="footer"></p>
		</details>
	</div>
	<dialog id="prefDialog">
		<div class="dialog-header">
			<h3 id="prefTitle" data-i18n="prefTitle"></h3>
			<button id="closePref" class="close-button" aria-label="Close Settings">&times;</button>
		</div>
		<div class="group">
			<label>
				<span id="langLabel" data-i18n="langLabel"></span>
				<select id="language"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
			</label>
			<label>
				<span id="themeLabel" data-i18n="themeLabel"></span>
				<select id="theme"><option value="auto">Auto</option><option value="light">Light</option><option value="dark">Dark</option></select>
			</label>
			<label>
				<span id="primaryCalLabel" data-i18n="primaryCalLabel"></span>
				<select id="primaryCalendar"><option value="gregorian">Gregorian</option><option value="hijri">Hijri</option></select>
			</label>
			<label>
				<span id="weekStartLabel" data-i18n="weekStartLabel"></span>
				<select id="weekStart"><option value="0">Sunday</option><option value="1">Monday</option><option value="6">Saturday</option></select>
			</label>
		</div>
		<div class="group">
			<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:.5rem">
				<label id="locLabel" style="margin-bottom:0" data-i18n="locLabel"></label>
				<button id="myLocBtn" style="width:auto; padding: .25rem .5rem; font-size:.8rem; background:transparent; color:var(--primary); border:none;" data-i18n="myLoc"></button>
			</div>
			<div class="row">
				<div style="flex:1"><label style="font-weight:normal; font-size:0.8em" data-i18n="latLabel"></label><input type="number" id="latInput" step="0.0001"></div>
				<div style="flex:1"><label style="font-weight:normal; font-size:0.8em" data-i18n="lonLabel"></label><input type="number" id="lonInput" step="0.0001"></div>
			</div>
		</div>
		<div class="group">
			<label id="adjLabel" data-i18n="adjLabel"></label>
			<input type="number" id="hijriAdj" value="0" min="-2" max="2">
			<small style="opacity: 0.6;" data-i18n="adjNote"></small>
		</div>
		<div style="display: flex; gap: 10px; margin-top: 1rem;">
			<button id="resetPrefBtn" class="secondary" data-i18n="reset"></button>
			<button id="savePrefBtn" class="primary" data-i18n="save"></button>
		</div>
	</dialog>
	<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
	<script>
		const text = {
			en: {
				appTitle: 'MABBIMS Hijri Calendar',
				gotoTitle: 'Go to Date',
				today: 'Today',
				formulaTitle: 'Heuristic Formula',
				formulaDesc: 'Optimized Tabular (Arafah) algorithm.',
				prefTitle: 'Preferences',
				langLabel: 'Language',
				themeLabel: 'Theme',
				primaryCalLabel: 'Primary Calendar',
				weekStartLabel: 'Week starts on',
				locLabel: 'Location',
				adjLabel: 'Hijri Adjustment (Days)',
				save: 'Save & Close',
				reset: 'Reset Defaults',
				myLoc: 'Use My Location',
				locating: 'Locating...',
				go: 'Go',
				goH: 'Go to Hijri',
				months: ["Muharram", "Safar", "Rabi' al-awwal", "Rabi' al-thani", "Jumada al-awwal", "Jumada al-thani", "Rajab", "Sha'ban", "Ramadan", "Shawwal", "Dhu al-Qi'dah", "Dhu al-Hijjah"],
				days: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				footer: '* Dates start at sunset. MABBIMS Criteria: Alt ≥ 3°, Elong ≥ 6.4°.',
				gDateLabel: 'Gregorian Date',
				hDayLabel: 'Hijri Day',
				hMonthLabel: 'Hijri Month',
				hYearLabel: 'Hijri Year',
				goBtnLabel: 'Go to Gregorian Date',
				goHBtnLabel: 'Go to Hijri Date',
				prevMonthLabel: 'Previous Month',
				nextMonthLabel: 'Next Month',
				prevBtn: '← Prev',
				nextBtn: 'Next →',
				yearPlaceholder: 'Year',
				offlineWarning: 'Offline Mode: Using approximate Tabular algorithm',
				geoNotSupported: 'Geolocation is not supported by this browser.',
				errorLocation: 'Error getting location: ',
				offlineSuffix: ' (Offline/Heuristic)',
				latLabel: 'Lat',
				lonLabel: 'Lon',
				adjNote: 'Shifts the Tabular formula.',
				themeAuto: 'Auto',
				themeLight: 'Light',
				themeDark: 'Dark',
				calGregorian: 'Gregorian',
				calHijri: 'Hijri',
				weekSun: 'Sunday',
				weekMon: 'Monday',
				weekSat: 'Saturday',
				dirN: 'N',
				dirS: 'S',
				dirE: 'E',
				dirW: 'W'
			},
			id: {
				appTitle: 'Kalender Hijriyah MABBIMS',
				gotoTitle: 'Ke Tanggal',
				today: 'Hari Ini',
				formulaTitle: 'Rumus Heuristik',
				formulaDesc: 'Algoritma Tabular (Arafah) yang dioptimalkan.',
				prefTitle: 'Pengaturan',
				langLabel: 'Bahasa',
				themeLabel: 'Tema',
				primaryCalLabel: 'Kalender Utama',
				weekStartLabel: 'Awal pekan',
				locLabel: 'Lokasi',
				adjLabel: 'Penyesuaian Hijriyah (Hari)',
				save: 'Simpan & Tutup',
				reset: 'Atur Ulang',
				myLoc: 'Gunakan Lokasi Saya',
				locating: 'Mencari lokasi...',
				go: 'Buka',
				goH: 'Buka Hijriyah',
				months: ["Muharram", "Safar", "Rabiul Awal", "Rabiul Akhir", "Jumadil Awal", "Jumadil Akhir", "Rajab", "Syaban", "Ramadhan", "Syawal", "Dzulkaidah", "Dzulhijjah"],
				days: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
				footer: '* Tanggal dimulai saat maghrib. Kriteria MABBIMS: Alt ≥ 3°, Elong ≥ 6.4°.',
				gDateLabel: 'Tanggal Masehi',
				hDayLabel: 'Hari Hijriyah',
				hMonthLabel: 'Bulan Hijriyah',
				hYearLabel: 'Tahun Hijriyah',
				goBtnLabel: 'Buka Tanggal Masehi',
				goHBtnLabel: 'Buka Tanggal Hijriyah',
				prevMonthLabel: 'Bulan Sebelumnya',
				nextMonthLabel: 'Bulan Berikutnya',
				prevBtn: '← Sblm',
				nextBtn: 'Lanjut →',
				yearPlaceholder: 'Tahun',
				offlineWarning: 'Mode Offline: Menggunakan algoritma Tabular perkiraan',
				geoNotSupported: 'Geolokasi tidak didukung oleh browser ini.',
				errorLocation: 'Gagal mendapatkan lokasi: ',
				offlineSuffix: ' (Offline/Heuristik)',
				latLabel: 'Lintang',
				lonLabel: 'Bujur',
				adjNote: 'Menggeser rumus Tabular.',
				themeAuto: 'Otomatis',
				themeLight: 'Terang',
				themeDark: 'Gelap',
				calGregorian: 'Masehi',
				calHijri: 'Hijriyah',
				weekSun: 'Minggu',
				weekMon: 'Senin',
				weekSat: 'Sabtu',
				dirN: 'LU',
				dirS: 'LS',
				dirE: 'BT',
				dirW: 'BB'
			}
		};
		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });

		let state = {
			lat: 21.3549,
			lon: 39.9841,
			lang: navigator.language?.startsWith('id') ? 'id' : 'en',
			theme: 'auto',
			weekStart: 0,
			hijriAdj: 0,
			primaryCalendar: 'gregorian'
		};

		class HijriCalc {
			constructor() {
				this.isOffline = (typeof Astronomy === 'undefined');
				this.cacheVersion = 1;
				this.loadState();
				state.viewDate = new Date();
				this.setup();
				this.updateLanguage(state.lang);
				this.applyTheme(state.theme);
				this.render();
				if (this.isOffline) {
					console.warn("Astronomy Engine not loaded. Using Tabular method.");
					const warning = document.createElement('div');
					warning.style.cssText = 'color:var(--danger);text-align:center;font-weight:400;margin-bottom:1rem';
					warning.setAttribute('data-i18n', 'offlineWarning');
					warning.textContent = text[state.lang].offlineWarning;
					document.querySelector('.container')?.insertBefore(warning, document.querySelector('.container').firstChild);
				}
			}

			loadState() {
				try {
					const saved = localStorage.getItem('hijriCalcState');
					if (saved) {
						const parsed = JSON.parse(saved);
						if (parsed.lat !== undefined) state.lat = parsed.lat;
						if (parsed.lon !== undefined) state.lon = parsed.lon;
						if (parsed.lang) state.lang = parsed.lang;
						if (parsed.theme) state.theme = parsed.theme;
						if (parsed.weekStart !== undefined) state.weekStart = parsed.weekStart;
						if (parsed.hijriAdj !== undefined) state.hijriAdj = parsed.hijriAdj;
						if (parsed.primaryCalendar) state.primaryCalendar = parsed.primaryCalendar;
					}
				} catch (e) { console.error("Failed to load state", e); }
			}

			loadCache() {
				try {
					const saved = localStorage.getItem('hijriCalcCache');
					if (saved) {
						const parsed = JSON.parse(saved);
						if (parsed.version === this.cacheVersion) this.cache = parsed.data;
						else this.cache = {};
					} else this.cache = {};
				} catch (e) { console.error("Failed to load cache", e); this.cache = {}; }
			}

			scheduleSaveCache() {
				if (this.saveTimeout) clearTimeout(this.saveTimeout);
				this.saveTimeout = setTimeout(() => this.saveCache(), 1000);
			}

			saveCache() {
				try { localStorage.setItem('hijriCalcCache', JSON.stringify({ version: this.cacheVersion, data: this.cache })); }
				catch (e) { console.warn("Failed to save cache", e); }
			}

			savePreferences() {
				state.lat = parseFloat(elements.latInput.value);
				state.lon = parseFloat(elements.lonInput.value);
				state.lang = elements.language.value;
				state.weekStart = parseInt(elements.weekStart.value);
				state.hijriAdj = parseInt(elements.hijriAdj.value);
				state.primaryCalendar = elements.primaryCalendar.value;
				state.theme = elements.theme.value;
				localStorage.setItem('hijriCalcState', JSON.stringify({
					lat: state.lat, lon: state.lon, lang: state.lang, weekStart: state.weekStart,
					hijriAdj: state.hijriAdj, primaryCalendar: state.primaryCalendar, theme: state.theme
				}));
				this.applyTheme(state.theme);
				this.updateLanguage(state.lang);
				this.render();
			}

			resetPreferences() {
				state.lat = 21.3549;
				state.lon = 39.9841;
				state.lang = navigator.language?.startsWith('id') ? 'id' : 'en';
				state.theme = 'auto';
				state.weekStart = 0;
				state.hijriAdj = 0;
				state.primaryCalendar = 'gregorian';
				elements.latInput.value = state.lat;
				elements.lonInput.value = state.lon;
				elements.language.value = state.lang;
				elements.weekStart.value = state.weekStart;
				elements.hijriAdj.value = state.hijriAdj;
				elements.primaryCalendar.value = state.primaryCalendar;
				elements.theme.value = state.theme;
				this.savePreferences();
			}

			applyTheme(theme) { document.documentElement.className = theme === 'auto' ? '' : theme; elements.theme.value = theme; }
			getTimezoneOffset() { return Math.round(state.lon / 15); }

			setup() {
				elements.latInput.value = state.lat;
				elements.lonInput.value = state.lon;
				elements.language.value = state.lang;
				elements.weekStart.value = state.weekStart;
				elements.hijriAdj.value = state.hijriAdj;
				elements.primaryCalendar.value = state.primaryCalendar;
				elements.theme.value = state.theme;
				this.setDateToInput(elements.gDateInput, new Date());
				text.en.months.forEach((month, index) => {
					const option = document.createElement('option');
					option.value = index;
					option.textContent = month;
					elements.hMonthInput.appendChild(option);
				});
				const hijri = this.gregorianToHijri(new Date());
				elements.hDayInput.value = hijri.day;
				elements.hMonthInput.value = hijri.month;
				elements.hYearInput.value = hijri.year;
				this.updateHijriDayLimit();

				elements.hMonthInput.addEventListener('change', () => this.updateHijriDayLimit());
				elements.hYearInput.addEventListener('change', () => this.updateHijriDayLimit());
				elements.hYearInput.addEventListener('input', () => this.updateHijriDayLimit());
				elements.prefBtn.onclick = () => elements.prefDialog.showModal();
				elements.closePref.onclick = () => elements.prefDialog.close();
				elements.savePrefBtn.onclick = () => { this.savePreferences(); elements.prefDialog.close(); };
				elements.resetPrefBtn.onclick = () => { this.resetPreferences(); elements.prefDialog.close(); };
				elements.myLocBtn.onclick = () => this.getLocation();
				elements.todayBtn.onclick = () => {
					state.viewDate = new Date();
					this.setDateToInput(elements.gDateInput, state.viewDate);
					this.updateHijriInputs(state.viewDate);
					this.render();
				};
				elements.prevMonthBtn.onclick = () => this.navigateMonth(-1);
				elements.nextMonthBtn.onclick = () => this.navigateMonth(1);

				const handleGo = () => {
					const date = this.getDateFromInput(elements.gDateInput);
					if (date) { state.viewDate = date; this.updateHijriInputs(date); this.render(); }
				};
				elements.gDateInput.addEventListener('change', handleGo);
				elements.gDateInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') handleGo(); });

				const handleGoH = () => {
					const day = parseInt(elements.hDayInput.value);
					const month = parseInt(elements.hMonthInput.value);
					const year = parseInt(elements.hYearInput.value);
					if (day && !isNaN(month) && year) {
						const gregorian = this.hijriToGregorian(year, month, day);
						state.viewDate = gregorian;
						this.render();
						this.setDateToInput(elements.gDateInput, gregorian);
					}
				};
				elements.goHBtn.onclick = handleGoH;
				[elements.hDayInput, elements.hMonthInput, elements.hYearInput].forEach(el => {
					el.addEventListener('keydown', (event) => { if (event.key === 'Enter') handleGoH(); });
				});

				elements.calendar.addEventListener('keydown', (event) => {
					const keys = ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown', 'Enter', ' '];
					if (!keys.includes(event.key)) return;
					const cell = event.target.closest('.day-cell');
					if (!cell) return;
					if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); cell.click(); return; }
					if (event.key === 'PageUp' || event.key === 'PageDown') {
						event.preventDefault();
						const currentDateStr = cell.dataset.date;
						if (!currentDateStr) return;
						const delta = (event.key === 'PageDown') ? 1 : -1;
						let targetDate;
						if (state.primaryCalendar === 'hijri') {
							const [year, month, day] = currentDateStr.split('-').map(Number);
							const date = new Date(year, month - 1, day);
							const hijri = this.gregorianToHijri(date);
							let newMonth = hijri.month + delta;
							let newYear = hijri.year;
							while (newMonth > 11) { newMonth -= 12; newYear++; }
							while (newMonth < 0) { newMonth += 12; newYear--; }
							targetDate = this.hijriToGregorian(newYear, newMonth, hijri.day);
						} else {
							const [year, month, day] = currentDateStr.split('-').map(Number);
							const targetMonthValue = month - 1 + delta;
							const checkDate = new Date(year, targetMonthValue, 1);
							const daysInMonth = new Date(checkDate.getFullYear(), checkDate.getMonth() + 1, 0).getDate();
							let targetDay = day;
							if (day > daysInMonth) targetDay = daysInMonth;
							targetDate = new Date(checkDate.getFullYear(), checkDate.getMonth(), targetDay);
						}
						this.navigateMonth(delta);
						const targetIso = `${targetDate.getFullYear()}-${String(targetDate.getMonth()+1).padStart(2,'0')}-${String(targetDate.getDate()).padStart(2,'0')}`;
						const targetCell = elements.calendar.querySelector(`.day-cell[data-date="${targetIso}"]`);
						if (targetCell) { cell.tabIndex = -1; targetCell.tabIndex = 0; targetCell.focus(); }
						else { const first = elements.calendar.querySelector('.day-cell'); if (first) { cell.tabIndex = -1; first.tabIndex = 0; first.focus(); } }
						return;
					}
					event.preventDefault();
					const cells = Array.from(elements.calendar.querySelectorAll('.day-cell'));
					const index = cells.indexOf(cell);
					if (index === -1) return;
					let newIndex = index;
					if (event.key === 'ArrowRight') newIndex++;
					else if (event.key === 'ArrowLeft') newIndex--;
					else if (event.key === 'ArrowDown') newIndex += 7;
					else if (event.key === 'ArrowUp') newIndex -= 7;
					else if (event.key === 'Home') newIndex = 0;
					else if (event.key === 'End') newIndex = cells.length - 1;
					if (newIndex >= 0 && newIndex < cells.length) {
						cell.tabIndex = -1;
						cells[newIndex].tabIndex = 0;
						cells[newIndex].focus();
					}
				});
			}

			navigateMonth(delta) {
				if (state.primaryCalendar === 'hijri') {
					const hijri = this.gregorianToHijri(state.viewDate);
					let newMonth = hijri.month + delta;
					let newYear = hijri.year;
					while (newMonth > 11) { newMonth -= 12; newYear++; }
					while (newMonth < 0) { newMonth += 12; newYear--; }
					const start = this.getAccurateHijriMonthStart(newYear, newMonth);
					state.viewDate = new Date(start.gDate.getTime() + 15 * 86400000);
				} else state.viewDate.setMonth(state.viewDate.getMonth() + delta);
				this.render();
			}

			updateHijriInputs(date) {
				const hijri = this.gregorianToHijri(date);
				elements.hDayInput.value = hijri.day;
				elements.hMonthInput.value = hijri.month;
				elements.hYearInput.value = hijri.year;
				this.updateHijriDayLimit();
			}

			updateHijriDayLimit() {
				const month = parseInt(elements.hMonthInput.value);
				const year = parseInt(elements.hYearInput.value);
				if (isNaN(month) || isNaN(year)) return;
				const currentStart = this.getAccurateHijriMonthStart(year, month);
				let nextMonth = month + 1;
				let nextYear = year;
				if (nextMonth > 11) { nextMonth = 0; nextYear++; }
				const nextStart = this.getAccurateHijriMonthStart(nextYear, nextMonth);
				const daysInMonth = Math.round((nextStart.gDate - currentStart.gDate) / 86400000);
				elements.hDayInput.max = daysInMonth;
				elements.hDayInput.placeholder = `1-${daysInMonth}`;
				if (parseInt(elements.hDayInput.value) > daysInMonth) elements.hDayInput.value = daysInMonth;
			}

			getLocation() {
				const translation = text[state.lang];
				if (navigator.geolocation) {
					const button = elements.myLocBtn;
					button.disabled = true;
					button.innerHTML = `<span class="spinner"></span> ${translation.locating}`;
					navigator.geolocation.getCurrentPosition(
						position => {
							elements.latInput.value = position.coords.latitude.toFixed(4);
							elements.lonInput.value = position.coords.longitude.toFixed(4);
							button.disabled = false;
							button.textContent = translation.myLoc;
						},
						error => {
							console.error(error);
							alert(translation.errorLocation + error.message);
							button.disabled = false;
							button.textContent = translation.myLoc;
						}
					);
				} else alert(translation.geoNotSupported);
			}

			formatCoordinates(latitude, longitude) {
				const t = text[state.lang];
				const latDir = latitude >= 0 ? t.dirN : t.dirS;
				const lonDir = longitude >= 0 ? t.dirE : t.dirW;
				return `${Math.abs(latitude)}° ${latDir}, ${Math.abs(longitude)}° ${lonDir}`;
			}

			getDateFromInput(input) {
				if (!input.value) return null;
				const [year, month, day] = input.value.split('-').map(Number);
				return new Date(year, month - 1, day);
			}

			setDateToInput(input, date) {
				const year = date.getFullYear();
				const month = String(date.getMonth() + 1).padStart(2, '0');
				const day = String(date.getDate()).padStart(2, '0');
				input.value = `${year}-${month}-${day}`;
			}

			updateLanguage(language) {
				const translation = text[language];
				document.querySelectorAll('[data-i18n]').forEach(el => {
					const key = el.getAttribute('data-i18n');
					if (translation[key]) el.textContent = translation[key];
				});
				document.querySelectorAll('[data-i18n-aria]').forEach(el => {
					const key = el.getAttribute('data-i18n-aria');
					if (translation[key]) el.setAttribute('aria-label', translation[key]);
				});
				document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
					const key = el.getAttribute('data-i18n-placeholder');
					if (translation[key]) el.placeholder = translation[key];
				});
				elements.appSubtitle.textContent = this.formatCoordinates(state.lat, state.lon);
				if (this.isOffline) elements.appSubtitle.textContent += translation.offlineSuffix;
				[...elements.hMonthInput.options].forEach((option, index) => { option.textContent = translation.months[index]; });

				[...elements.theme.options].forEach(opt => opt.textContent = translation['theme' + opt.value.charAt(0).toUpperCase() + opt.value.slice(1)]);
				[...elements.primaryCalendar.options].forEach(opt => opt.textContent = translation['cal' + opt.value.charAt(0).toUpperCase() + opt.value.slice(1)]);
				const weekDays = [translation.weekSun, translation.weekMon, null, null, null, null, translation.weekSat];
				[...elements.weekStart.options].forEach(opt => {
					const day = weekDays[parseInt(opt.value)];
					if (day) opt.textContent = day;
				});
			}

			hijriToGregorianTabular(hYear, hMonth, hDay) {
				const epoch = 1948439.5 + state.hijriAdj;
				const year = hYear - 1;
				const cycle = Math.floor(year / 30);
				const yearInCycle = year % 30;
				const dayInCycle = yearInCycle * 354 + Math.floor((11 * yearInCycle + 11) / 30);
				const dayInYear = Math.ceil(29.5 * hMonth);
				const jd = epoch + cycle * 10631 + dayInCycle + dayInYear + hDay - 1;

				let z = Math.floor(jd + 0.5);
				let f = jd + 0.5 - z;
				let alpha = Math.floor((z - 1867216.25) / 36524.25);
				let a = z + 1 + alpha - Math.floor(alpha / 4);
				let b = a + 1524;
				let c = Math.floor((b - 122.1) / 365.25);
				let d = Math.floor(365.25 * c);
				let e = Math.floor((b - d) / 30.6001);
				let day = b - d - Math.floor(30.6001 * e) + f;
				let monthResult = e - 1;
				if (monthResult > 12) monthResult -= 12;
				let yearResult = c - 4715;
				if (e < 14) monthResult = e - 1; else monthResult = e - 13;
				if (monthResult > 2) yearResult = c - 4716; else yearResult = c - 4715;
				return new Date(yearResult, monthResult - 1, Math.floor(day));
			}

			hijriToGregorian(hYear, hMonth, hDay) {
				if (this.isOffline) return this.hijriToGregorianTabular(hYear, hMonth, hDay);
				const start = this.getAccurateHijriMonthStart(hYear, hMonth);
				const gregorian = new Date(start.gDate);
				gregorian.setDate(gregorian.getDate() + (hDay - 1));
				return gregorian;
			}

			gregorianToHijriTabular(date) {
				let day = date.getDate();
				let month = date.getMonth();
				let year = date.getFullYear();
				let m = month + 1;
				let y = year;
				if (m < 3) { y -= 1; m += 12; }
				let a = Math.floor(y / 100);
				let b = 2 - a + Math.floor(a / 4);
				if (y < 1583) b = 0;
				if (y === 1582) {
					if (m > 10) b = -10;
					if (m === 10) { b = 0; if (day > 4) b = -10; }
				}
				let jd = Math.floor(365.25 * (y + 4716)) + Math.floor(30.6001 * (m + 1)) + day + b - 1524;

				const epoch = 1948439.5 + state.hijriAdj;
				let jdNoon = jd - epoch;
				let cycle = Math.floor(jdNoon / 10631);
				let dayInCycle = jdNoon % 10631;

				let yCycle = Math.floor(dayInCycle / 355);
				if (yCycle > 29) yCycle = 29;
				while (yCycle < 30) {
					let daysNext = (yCycle + 1) * 354 + Math.floor((11 * (yCycle + 1) + 11) / 30);
					if (dayInCycle < daysNext) break;
					yCycle++;
				}

				let daysInPastYears = yCycle * 354 + Math.floor((11 * yCycle + 11) / 30);
				let dayInYear = dayInCycle - daysInPastYears;

				let mYear = Math.floor(dayInYear / 29.5);
				if (mYear > 11) mYear = 11;
				while (mYear < 12) {
					let daysNext = Math.ceil(29.5 * (mYear + 1));
					if (dayInYear < daysNext) break;
					mYear++;
				}

				let daysInPastMonths = Math.ceil(29.5 * mYear);
				let dMonth = dayInYear - daysInPastMonths + 1;

				let hYear = cycle * 30 + yCycle + 1;
				return { day: Math.floor(dMonth), month: mYear, year: hYear };
			}

			gregorianToHijri(date) {
				if (this.isOffline) return this.gregorianToHijriTabular(date);
				const approx = this.gregorianToHijriTabular(date);
				const startCurrent = this.getAccurateHijriMonthStart(approx.year, approx.month);
				const dateTime = date.getTime();
				const startTime = startCurrent.gDate.getTime();
				if (dateTime < startTime) {
					let prevMonth = approx.month - 1;
					let prevYear = approx.year;
					if (prevMonth < 0) { prevMonth = 11; prevYear--; }
					const startPrev = this.getAccurateHijriMonthStart(prevYear, prevMonth);
					const day = Math.round((dateTime - startPrev.gDate.getTime()) / 86400000) + 1;
					return { day: day, month: prevMonth, year: prevYear };
				}
				let nextMonth = approx.month + 1;
				let nextYear = approx.year;
				if (nextMonth > 11) { nextMonth = 0; nextYear++; }
				const startNext = this.getAccurateHijriMonthStart(nextYear, nextMonth);
				const nextTime = startNext.gDate.getTime();
				if (dateTime >= nextTime) {
					const day = Math.round((dateTime - nextTime) / 86400000) + 1;
					return { day: day, month: nextMonth, year: nextYear };
				}
				const day = Math.round((dateTime - startTime) / 86400000) + 1;
				return { day: day, month: approx.month, year: approx.year };
			}

			checkVisibility(dateObj, knownNewMoonUT) {
				const utcOffset = this.getTimezoneOffset();
				const baseUTC = new Date(dateObj);
				baseUTC.setHours(12 - utcOffset);
				const date = Astronomy.MakeTime(baseUTC);
				const observer = new Astronomy.Observer(state.lat, state.lon, 0);
				const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, date.ut, 1);
				if (!sunset) return false;
				const sunsetUT = sunset.ut;
				const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
				const moonHor = Astronomy.Horizon(sunsetUT, observer, moonEq.ra, moonEq.dec, "normal");
				const sunEq = Astronomy.Equator(Astronomy.Body.Sun, sunsetUT, observer, true, true);
				const elongation = Astronomy.AngleBetween(sunEq.vec, moonEq.vec);
				let newMoonUT = knownNewMoonUT;
				if (newMoonUT === undefined || newMoonUT === null) {
					const searchCenter = Astronomy.MakeTime(dateObj);
					const bestNewMoon = Astronomy.SearchMoonPhase(0, searchCenter.ut, -35);
					if (!bestNewMoon) return false;
					newMoonUT = bestNewMoon.ut;
				}
				const age = sunsetUT - newMoonUT;
				if (age < 0) return false;
				const altitude = moonHor.altitude;
				return (altitude >= 3.0 && elongation >= 6.4);
			}

			getAccurateHijriMonthStart(hYear, hMonth) {
				if (this.isOffline) return { gDate: this.hijriToGregorianTabular(hYear, hMonth, 1) };
				if (!this.cache) this.loadCache();
				const cacheKey = `${hYear}-${hMonth}-${state.lat}-${state.lon}`;
				if (this.cache[cacheKey]) {
					if (typeof this.cache[cacheKey].gDate === 'string') this.cache[cacheKey].gDate = new Date(this.cache[cacheKey].gDate);
					return this.cache[cacheKey];
				}
				const daysSinceAnchor = ((hYear - 1445) * 354.367) + (hMonth * 29.53);
				const anchorDate = new Date("2023-07-19T12:00:00Z");
				const approxDate = new Date(anchorDate.getTime() + daysSinceAnchor * 86400000);
				const searchStart = new Date(approxDate.getTime() - 5 * 86400000);
				const timeStart = Astronomy.MakeTime(searchStart);
				let bestNewMoon = Astronomy.SearchMoonPhase(0, timeStart.ut, 10);
				if (!bestNewMoon || Math.abs(bestNewMoon.date - approxDate) > 4 * 86400000) return { gDate: approxDate };
				const newMoonDate = bestNewMoon.date;
				const utcOffset = this.getTimezoneOffset();
				newMoonDate.setMinutes(newMoonDate.getMinutes() + utcOffset * 60);
				let checkDate = new Date(newMoonDate.getFullYear(), newMoonDate.getMonth(), newMoonDate.getDate());
				let isVisible = this.checkVisibility(checkDate, bestNewMoon.ut);
				const startDate = new Date(checkDate);
				startDate.setDate(checkDate.getDate() + (isVisible ? 1 : 2));
				const result = { gDate: startDate };
				this.cache[cacheKey] = result;
				this.scheduleSaveCache();
				return result;
			}

			render() {
				const grid = elements.calendar;
				const translation = text[state.lang];
				if (state.primaryCalendar === 'hijri') grid.classList.add('hijri-primary');
				else grid.classList.remove('hijri-primary');

				if (state.primaryCalendar !== 'hijri') {
					const year = state.viewDate.getFullYear();
					const month = state.viewDate.getMonth();
					const langCode = state.lang === 'id' ? 'id-ID' : 'en-US';
					elements.monthDisplay.textContent = state.viewDate.toLocaleDateString(langCode, { month: 'long', year: 'numeric' });
					const firstDayOfMonth = new Date(year, month, 1);
					let dayOfWeek = firstDayOfMonth.getDay();
					let offset = dayOfWeek - state.weekStart;
					if (offset < 0) offset += 7;
					const gridStartDate = new Date(year, month, 1 - offset);
					this.renderGrid(gridStartDate, true, { month, year });
					return;
				}

				const hijri = this.gregorianToHijri(state.viewDate);
				const currentStart = this.getAccurateHijriMonthStart(hijri.year, hijri.month);
				let nextMonth = hijri.month + 1;
				let nextYear = hijri.year;
				if (nextMonth > 11) { nextMonth = 0; nextYear++; }
				const nextStart = this.getAccurateHijriMonthStart(nextYear, nextMonth);
				elements.monthDisplay.textContent = `${translation.months[hijri.month]} ${hijri.year}`;
				const startDayOfWeek = currentStart.gDate.getDay();
				let offset = startDayOfWeek - state.weekStart;
				if (offset < 0) offset += 7;
				const gridStartDate = new Date(currentStart.gDate);
				gridStartDate.setDate(gridStartDate.getDate() - offset);
				this.renderGrid(gridStartDate, false, { hMonth: hijri.month, hYear: hijri.year, startGDate: currentStart.gDate, endGDate: nextStart.gDate });
			}

			renderGrid(gridStartDate, isGregorianMode, context) {
				const grid = elements.calendar;
				const translation = text[state.lang];
				grid.setAttribute('role', 'grid');
				grid.innerHTML = '';
				for (let index = 0; index < 7; index++) {
					let dayIndex = (state.weekStart + index) % 7;
					const element = document.createElement('div');
					element.className = 'day-header';
					element.textContent = translation.days[dayIndex];
					element.setAttribute('role', 'columnheader');
					grid.appendChild(element);
				}

				let hijriStarts = [];
				if (isGregorianMode) {
					const startHijri = this.gregorianToHijri(gridStartDate);
					let hMonthIndex = startHijri.month;
					let hYear = startHijri.year;
					for (let index = -1; index <= 2; index++) {
						let month = hMonthIndex + index;
						let year = hYear;
						while (month > 11) { month -= 12; year++; }
						while (month < 0) { month += 12; year--; }
						const start = this.getAccurateHijriMonthStart(year, month);
						hijriStarts.push({ year: year, month: month, gDate: start.gDate });
					}
					hijriStarts.sort((a, b) => a.gDate - b.gDate);
				}

				const today = new Date();
				today.setHours(0, 0, 0, 0);
				const selectedDate = this.getDateFromInput(elements.gDateInput);
				const selectedTime = selectedDate ? selectedDate.getTime() : -1;

				for (let index = 0; index < 42; index++) {
					const date = new Date(gridStartDate);
					date.setDate(gridStartDate.getDate() + index);
					const dateNoTime = new Date(date).setHours(0, 0, 0, 0);
					let hijriDateDisplay = "";
					let hijriMonthNameDisplay = "";

					if (isGregorianMode) {
						for (let k = 0; k < hijriStarts.length - 1; k++) {
							const s1 = hijriStarts[k];
							const s2 = hijriStarts[k + 1];
							if (date >= s1.gDate && date < s2.gDate) {
								const startTime = new Date(s1.gDate).setHours(0, 0, 0, 0);
								const dayNumber = Math.round((dateNoTime - startTime) / 86400000) + 1;
								hijriDateDisplay = dayNumber;
								hijriMonthNameDisplay = translation.months[s1.month];
								break;
							}
						}
					} else {
						if (date >= context.startGDate && date < context.endGDate) {
							const start = new Date(context.startGDate).setHours(0, 0, 0, 0);
							hijriDateDisplay = Math.round((dateNoTime - start) / 86400000) + 1;
						} else {
							const start = new Date(context.startGDate).setHours(0, 0, 0, 0);
							const diff = Math.round((dateNoTime - start) / 86400000) + 1;
							if (date < context.startGDate) {
								let prevMonth = context.hMonth - 1;
								let prevYear = context.hYear;
								if (prevMonth < 0) { prevMonth += 12; prevYear--; }
								const prevStart = this.getAccurateHijriMonthStart(prevYear, prevMonth);
								let prevLength = Math.round((context.startGDate - prevStart.gDate) / 86400000);
								if (prevLength < 29 || prevLength > 30) prevLength = 30;
								hijriDateDisplay = prevLength + diff;
								hijriMonthNameDisplay = translation.months[prevMonth];
							} else {
								let length = Math.round((context.endGDate - context.startGDate) / 86400000);
								if (length < 29 || length > 30) length = 30;
								hijriDateDisplay = diff - length;
								let nm = context.hMonth + 1;
								if (nm > 11) nm = 0;
								hijriMonthNameDisplay = translation.months[nm];
							}
						}
					}

					const element = document.createElement('div');
					element.className = 'day-cell';
					element.setAttribute('role', 'gridcell');
					element.tabIndex = -1;

					if (isGregorianMode) { if (date.getMonth() !== context.month) element.classList.add('other-month'); }
					else { if (date < context.startGDate || date >= context.endGDate) element.classList.add('other-month'); }

					const dateTime = date.getTime();
					if (dateTime === today.getTime()) element.classList.add('today');
					if (dateTime === selectedTime) {
						element.classList.add('selected');
						element.setAttribute('aria-selected', 'true');
					}

					element.onclick = () => {
						this.setDateToInput(elements.gDateInput, date);
						this.updateHijriInputs(date);
						this.render();
						const selected = elements.calendar.querySelector('.day-cell.selected');
						if (selected) selected.focus();
					};

					const fullDate = date.toLocaleDateString(state.lang === 'id' ? 'id-ID' : 'en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
					element.setAttribute('aria-label', `${fullDate}, ${hijriDateDisplay} ${hijriMonthNameDisplay}`);
					element.dataset.date = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

					const monthNameShort = date.toLocaleDateString(state.lang === 'id' ? 'id-ID' : 'en-US', { month: 'short' });
					const gregorianText = isGregorianMode ? date.getDate() : `${date.getDate()} ${monthNameShort}`;

					element.innerHTML = `
						<div class="gregorian-date">${gregorianText}</div>
						<div class="hijri-wrapper">
							<div class="hijri-date">${hijriDateDisplay}</div>
							<div class="hijri-month-name">${hijriMonthNameDisplay}</div>
						</div>
					`;
					grid.appendChild(element);
				}

				const cells = grid.querySelectorAll('.day-cell');
				let focusCandidate = grid.querySelector('.day-cell.selected');
				if (!focusCandidate) focusCandidate = grid.querySelector('.day-cell.today');
				if (!focusCandidate && cells.length > 0) focusCandidate = cells[0];
				if (focusCandidate) focusCandidate.tabIndex = 0;
			}
		}
		new HijriCalc();
	</script>
</body>
</html>
