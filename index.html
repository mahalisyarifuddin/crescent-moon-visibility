<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>Hilal Visibility Map</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
		<style>

:root { --primary: #005dac; --on-primary: #ffffff; --hover: #00539a; --background: #f9f9ff; --surface: #ffffff; --text: #181c21; --border: #c1c6d4; --muted: #f2f3fc; --success: #0b6b1d; --on-success: #ffffff; --danger: #ba1a1a; --on-danger: #ffffff; --highlight-bg: #d4e3ff; }
@media (prefers-color-scheme: dark) { :root:not(.light) { --primary: #a5c8ff; --on-primary: #00315f; --hover: #72adff; --background: #101319; --surface: #0b0e14; --text: #e0e2ea; --border: #414752; --muted: #181c21; --success: #82db7e; --on-success: #00390a; --danger: #ffb4ab; --on-danger: #93000a; --highlight-bg: #001c3a; } }
:root.dark { --primary: #a5c8ff; --on-primary: #00315f; --hover: #72adff; --background: #101319; --surface: #0b0e14; --text: #e0e2ea; --border: #414752; --muted: #181c21; --success: #82db7e; --on-success: #00390a; --danger: #ffb4ab; --on-danger: #93000a; --highlight-bg: #001c3a; }
* { box-sizing: border-box; margin: 0; padding: 0; outline-offset: 2px; }
*:focus-visible { outline: 2px solid var(--primary); }
body { background: var(--background); color: var(--text); font-family: sans-serif; display: flex; justify-content: center; min-height: 100vh; padding: 1rem; }
.container { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; max-width: 1200px; padding: 2rem; width: 100%; position: relative; margin: 2rem 0; display: flex; flex-direction: column; }
.hidden { display: none !important; }
h1, h2, h3, label { margin: .5rem 0; }
label { display: block; font-weight: 700; }
input, select, button { background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 1rem; padding: .5rem; width: 100%; }
button { cursor: pointer; }
button:disabled { opacity: .6; cursor: not-allowed; }
.primary { background: var(--primary); color: var(--on-primary); border: 0; }
.primary:hover:not(:disabled) { background: var(--hover); }
.secondary:hover:not(:disabled) { background: var(--muted); }
.selectors { position: absolute; right: 2rem; top: 1rem; display: flex; gap: 8px; z-index: 1000; }
.row { display: flex; gap: 1rem; margin-bottom: 1rem; }
.group { flex: 1; }
.info { font-size: .9rem; opacity: .8; line-height: 1.6; }
#map { width: 100%; height: 500px; border: 1px solid var(--border); border-radius: 4px; margin-top: 1rem; }
.tabs { display: flex; border-bottom: 1px solid var(--border); margin-bottom: 1rem; }
.tab { background: transparent; border: none; border-bottom: 3px solid transparent; border-radius: 0; cursor: pointer; padding: 0.5rem 1rem; font-weight: 600; color: var(--text); opacity: 0.6; width: auto; }
.tab:hover { background: var(--muted); opacity: 1; }
.tab.active { border-bottom-color: var(--primary); opacity: 1; }
#results { margin-top: 1rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; }
.result-card { background: var(--surface); padding: 1rem; border-radius: 4px; border: 1px solid var(--border); box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
.result-label { font-size: 0.8rem; opacity: 0.8; margin-bottom: 0.25rem; }
.result-value { font-size: 1.2rem; font-weight: bold; }
@media(max-width: 768px) { .selectors { position: static; justify-content: end; margin-bottom: .5rem; } .row { flex-direction: column; } #map { height: 350px; } }

		</style>
	</head>
	<body>
		<div class="container">
            <div class="selectors">
				<select id="language">
					<option value="en">English</option>
					<option value="id">Bahasa Indonesia</option>
				</select>
				<select id="theme">
					<option value="auto">Auto</option>
					<option value="light">Light</option>
					<option value="dark">Dark</option>
				</select>
			</div>

            <h1 id="mapTitle">Hilal Visibility Map</h1>

            <div class="tabs">
                <button id="tabMap" class="tab active">Map</button>
                <button id="tabCalc" class="tab">Detailed Calculations</button>
            </div>

            <div id="mapView">
                <div id="controls">
                    <div class="row">
                    <div class="group">
                        <label id="dateLabel" for="mapDate">Date</label>
                        <input type="date" id="mapDate">
                    </div>
                    <div class="group">
                        <label id="regionLabel" for="mapRegion">Region</label>
                        <select id="mapRegion">
                            <option value="indonesia">Indonesia</option>
                            <option value="world">World</option>
                        </select>
                    </div>
                    <div class="group">
                        <label id="criteriaLabel" for="mapCriteria">Criteria</label>
                        <select id="mapCriteria">
                            <option value="mabbims">MABBIMS (Alt‚â•3¬∞, Elong‚â•6.4¬∞)</option>
                            <option value="gic">Global Islamic (Alt‚â•5¬∞, Elong‚â•8¬∞, <12am UTC)</option>
                            <option value="alt0">Altitude > 0¬∞</option>
                            <option value="custom">Custom Criteria</option>
                        </select>
                    </div>
                </div>

                <div class="row hidden" id="customCriteriaInputs">
                    <div class="group">
                        <label id="minAltLabel" for="minAlt">Min Altitude (¬∞)</label>
                        <input type="number" id="minAlt" value="0" step="0.1">
                    </div>
                    <div class="group">
                        <label id="minElongLabel" for="minElong">Min Elongation (¬∞)</label>
                        <input type="number" id="minElong" value="0" step="0.1">
                    </div>
                </div>

                <div class="row">
                    <button id="renderMap" class="primary">Render Map</button>
                </div>
            </div>

            <div id="mapStatus" class="info" style="font-style:italic; min-height: 1.2em;"></div>
            <div id="map"></div>

            <div id="mapLegend" class="info" style="margin-top:0.5rem">
                <span style="display:inline-block;width:12px;height:12px;background:rgba(0, 255, 0, 0.5);margin-right:4px;border:1px solid green"></span><span id="legendVisible">Visible</span>
            </div>
            </div> <!-- End mapView -->

            <div id="calcView" class="hidden">
                <div class="row">
                    <div class="group">
                        <label id="calcDateLabel" for="calcDate">Date</label>
                        <input type="date" id="calcDate">
                    </div>
                    <div class="group">
                         <label id="calcLatLabel" for="calcLat">Latitude</label>
                         <input type="number" id="calcLat" step="0.0001" placeholder="-6.2000">
                    </div>
                    <div class="group">
                         <label id="calcLonLabel" for="calcLon">Longitude</label>
                         <input type="number" id="calcLon" step="0.0001" placeholder="106.8166">
                    </div>
                </div>
                 <div class="row">
                     <div class="group">
                        <label id="calcCriteriaLabel" for="calcCriteria">Criteria</label>
                        <select id="calcCriteria">
                            <option value="mabbims">MABBIMS</option>
                            <option value="gic">Global Islamic</option>
                            <option value="alt0">Altitude > 0¬∞</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                     <div class="group">
                         <button id="getLocation" class="secondary" style="margin-top: 1.7rem;">üìç Use My Location</button>
                     </div>
                </div>

                <div class="row hidden" id="calcCustomCriteriaInputs">
                    <div class="group">
                        <label for="calcMinAlt">Min Altitude (¬∞)</label>
                        <input type="number" id="calcMinAlt" value="0" step="0.1">
                    </div>
                    <div class="group">
                        <label for="calcMinElong">Min Elongation (¬∞)</label>
                        <input type="number" id="calcMinElong" value="0" step="0.1">
                    </div>
                </div>

                <div class="row">
                    <button id="calculateBtn" class="primary">Calculate</button>
                </div>

                <div id="results"></div>
            </div>

		</div>

        <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

		<script>
			const WORKER_SOURCE = `// Inlined worker.js content
importScripts('https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js');

const RESOLUTION_FACTOR = 0.25; // 1/4th resolution = 16x faster
const INTERP_STEP = 10; // Interpolate every 10 *calculated* pixels

self.onmessage = function(e) {
    const {
        bounds,
        widthDeg,
        heightDeg,
        mapSizeX,
        criteria,
        dateTimestamp,
        minAlt: criteriaMinAlt,
        minElong: criteriaMinElong
    } = e.data;

    try {
        const date = Astronomy.MakeTime(new Date(dateTimestamp));

        let minAlt = 0, minElong = 0, isGIC = false;
        if (criteria === 'mabbims') { minAlt = 3; minElong = 6.4; }
        else if (criteria === 'gic') { minAlt = 5; minElong = 8; isGIC = true; }
        else if (criteria === 'alt0') { minAlt = 0; minElong = -100; }
        else if (criteria === 'custom') {
            minAlt = criteriaMinAlt;
            minElong = criteriaMinElong;
        }

        // Calculate PPD based on screen resolution and zoom, applied with RESOLUTION_FACTOR
        const PPD = (mapSizeX / widthDeg) * RESOLUTION_FACTOR;

        const width = Math.ceil(widthDeg * PPD);
        const height = Math.ceil(heightDeg * PPD);

        // Prepare buffer
        // RGBA = 4 bytes
        const buffer = new Uint8ClampedArray(width * height * 4);

        const totalPixels = width * height;
        const observer = new Astronomy.Observer(0, 0, 0);
        let currentY = -1;
        let sunsetBase = null;

        let prevRA, prevDec, prevElong, prevAlt;
        let nextRA, nextDec, nextElong, nextAlt;
        let cachedNextRA, cachedNextDec, cachedNextElong, cachedNextAlt;

        // Progress reporting interval
        const progressInterval = Math.floor(totalPixels / 20);
        let lastReported = 0;

        for (let pixelIndex = 0; pixelIndex < totalPixels; pixelIndex++) {
            // Report progress occasionally
            if (pixelIndex - lastReported > progressInterval) {
                self.postMessage({ status: 'progress', percent: Math.round(pixelIndex / totalPixels * 100) });
                lastReported = pixelIndex;
            }

            const x = pixelIndex % width;
            const y = Math.floor(pixelIndex / width);

            // Map pixel back to lat/lon
            const lat = bounds.maxLat - (y / PPD);
            const lon = bounds.minLon + (x / PPD);

            if (y !== currentY) {
                currentY = y;
                observer.latitude = lat;
                observer.longitude = 0;
                const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, date.ut, 1);
                sunsetBase = sunset ? sunset.ut : null;
                // Reset interpolation state on new row
                prevRA = undefined;
                cachedNextRA = undefined;
            }

            if (sunsetBase !== null) {
                observer.latitude = lat;
                observer.longitude = lon;

                const sunsetUT = sunsetBase - (lon / 360.0);
                let moonRA, moonDec, moonElong;
                let moonAlt;

                const xMod = x % INTERP_STEP;

                if (xMod === 0 || prevRA === undefined) {
                    if (x > 0 && prevRA !== undefined && cachedNextRA !== undefined) {
                        prevRA = cachedNextRA;
                        prevDec = cachedNextDec;
                        prevElong = cachedNextElong;
                        prevAlt = cachedNextAlt;
                    } else {
                        const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
                        prevRA = moonEq.ra;
                        prevDec = moonEq.dec;
                        prevElong = Astronomy.AngleFromSun(Astronomy.Body.Moon, sunsetUT);
                        const moonHor = Astronomy.Horizon(sunsetUT, observer, prevRA, prevDec, 'normal');
                        prevAlt = moonHor.altitude;
                    }

                    // Calculate next keyframe
                    let nextX = x + INTERP_STEP;
                    if (nextX >= width) nextX = width - 1;

                    if (nextX > x) {
                        const nextLon = bounds.minLon + (nextX / PPD);
                        const nextSunsetUT = sunsetBase - (nextLon / 360.0);
                        observer.longitude = nextLon;

                        const nextMoonEq = Astronomy.Equator(Astronomy.Body.Moon, nextSunsetUT, observer, true, true);
                        cachedNextRA = nextMoonEq.ra;
                        cachedNextDec = nextMoonEq.dec;
                        cachedNextElong = Astronomy.AngleFromSun(Astronomy.Body.Moon, nextSunsetUT);
                        const nextMoonHor = Astronomy.Horizon(nextSunsetUT, observer, nextMoonEq.ra, nextMoonEq.dec, 'normal');
                        cachedNextAlt = nextMoonHor.altitude;

                        nextRA = cachedNextRA;
                        nextDec = cachedNextDec;
                        nextElong = cachedNextElong;
                        nextAlt = cachedNextAlt;

                        if (Math.abs(nextRA - prevRA) > 12) {
                            if (nextRA > prevRA) prevRA += 24;
                            else nextRA += 24;
                        }
                        observer.longitude = lon;
                    } else {
                        nextRA = prevRA;
                        nextDec = prevDec;
                        nextElong = prevElong;
                        nextAlt = prevAlt;
                        cachedNextRA = undefined;
                    }

                    moonRA = prevRA;
                    moonDec = prevDec;
                    moonElong = prevElong;
                    moonAlt = prevAlt;
                } else {
                    const fraction = xMod / INTERP_STEP;
                    moonRA = prevRA + (nextRA - prevRA) * fraction;
                    moonDec = prevDec + (nextDec - prevDec) * fraction;
                    moonElong = prevElong + (nextElong - prevElong) * fraction;
                    moonAlt = prevAlt + (nextAlt - prevAlt) * fraction;

                    if (moonRA >= 24) moonRA -= 24;
                }

                // Check visibility
                // Logic copied from index.html checkVisibility
                let visible = false;

                // --- checkVisibility logic inlined ---
                let isVisibleGIC = true;
                if (isGIC) {
                    if (sunsetUT >= (date.ut + 0.5)) isVisibleGIC = false;
                }

                if (isVisibleGIC) {
                    // We already have moonAlt calculated/interpolated
                    if (moonAlt >= minAlt) {
                         const elong = moonElong; // Already have it
                         if (elong >= minElong) {
                             visible = true;
                         }
                    }
                }
                // -------------------------------------

                if (visible) {
                    const idx = pixelIndex * 4;
                    buffer[idx] = 0;     // R
                    buffer[idx+1] = 255; // G
                    buffer[idx+2] = 0;   // B
                    buffer[idx+3] = 128; // A
                }
            }
        }

        self.postMessage({
            status: 'complete',
            buffer: buffer,
            width: width,
            height: height
        }, [buffer.buffer]);

    } catch (e) {
        self.postMessage({ status: 'error', message: e.message });
    }
};
`;
			const text = {
				en: {
					autoTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
                    mapTitle: 'Hilal Visibility Map',
                    renderMap: 'Render Map',
                    dateLabel: 'Date',
                    regionLabel: 'Region',
                    criteriaLabel: 'Criteria',
                    legendVisible: 'Visible',
                    minAltLabel: 'Min Altitude (¬∞)',
                    minElongLabel: 'Min Elongation (¬∞)',
                    languageLabel: 'Language',
					themeLabel: 'Theme',
                    calcDateLabel: 'Date',
                    calcLatLabel: 'Latitude',
                    calcLonLabel: 'Longitude',
                    calcCriteriaLabel: 'Criteria',
                    calculateBtn: 'Calculate',
                    tabMap: 'Map',
                    tabCalc: 'Detailed Calculations',
                    getLocation: 'üìç Use My Location',
                    sunsetTime: 'Sunset Time',
                    moonsetTime: 'Moonset Time',
                    moonAge: 'Moon Age',
                    moonAlt: 'Moon Altitude',
                    moonElong: 'Elongation',
                    moonAzimuth: 'Moon Azimuth',
                    moonWidth: 'Moon Width',
                    illuminatedFraction: 'Illuminated Fraction',
                    visibilityStatus: 'Visibility Status',
                    visible: 'Visible',
                    notVisible: 'Not Visible'
				},
				id: {
					autoTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
                    mapTitle: 'Peta Visibilitas Hilal',
                    renderMap: 'Render Peta',
                    dateLabel: 'Tanggal',
                    regionLabel: 'Wilayah',
                    criteriaLabel: 'Kriteria',
                    legendVisible: 'Terlihat',
                    minAltLabel: 'Min Tinggi (¬∞)',
                    minElongLabel: 'Min Elongasi (¬∞)',
                    languageLabel: 'Bahasa',
					themeLabel: 'Tema',
                    calcDateLabel: 'Tanggal',
                    calcLatLabel: 'Lintang',
                    calcLonLabel: 'Bujur',
                    calcCriteriaLabel: 'Kriteria',
                    calculateBtn: 'Hitung',
                    tabMap: 'Peta',
                    tabCalc: 'Hitung Detail',
                    getLocation: 'üìç Lokasi Saya',
                    sunsetTime: 'Waktu Matahari Terbenam',
                    moonsetTime: 'Waktu Bulan Terbenam',
                    moonAge: 'Umur Bulan',
                    moonAlt: 'Tinggi Bulan',
                    moonElong: 'Elongasi',
                    moonAzimuth: 'Azimuth Bulan',
                    moonWidth: 'Lebar Bulan',
                    illuminatedFraction: 'Fraksi Iluminasi',
                    visibilityStatus: 'Status Visibilitas',
                    visible: 'Terlihat',
                    notVisible: 'Tidak Terlihat'
				}
			};
			const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });

			class VisibilityMap {
				constructor() {
					this.setup();
					this.theme('auto');
					this.lang(navigator.language?.startsWith('id') ? 'id' : 'en');
				}
				setup() {
					elements.language.onchange = event => this.lang(event.target.value);
					elements.theme.onchange = event => this.theme(event.target.value);
                    elements.renderMap.onclick = () => this.handleRenderClick();
                    elements.mapCriteria.onchange = () => this.toggleCustom();
                    elements.mapRegion.onchange = () => this.handleRegionChange();

                    elements.tabMap.onclick = () => this.switchTab('map');
                    elements.tabCalc.onclick = () => this.switchTab('calc');
                    elements.calcCriteria.onchange = () => this.toggleCustomCalc();
                    elements.calculateBtn.onclick = () => this.calculateDetails();
                    elements.getLocation.onclick = () => this.getCurrentLocation();

                    const today = new Date();
                    elements.mapDate.valueAsDate = today;
                    elements.calcDate.valueAsDate = today;

                    this.map = L.map('map').setView([-2.5, 118], 5);
                    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }).addTo(this.map);

                    this.overlayLayer = null;
                    this.isRendering = false;
                    const blob = new Blob([WORKER_SOURCE], { type: 'application/javascript' });
                    this.workerUrl = URL.createObjectURL(blob);
                    this.worker = new Worker(this.workerUrl);
                    this.worker.onmessage = (e) => this.handleWorkerMessage(e);
				}
				string(key) {
					return text[this.language]?.[key] ?? key;
				}
				theme(themeName) {
					document.documentElement.className = themeName === 'auto' ? '' : themeName;
					elements.theme.value = themeName;
				}
				lang(language) {
					this.language = elements.language.value = document.documentElement.lang = language;
					Object.keys(text.en).forEach(key => elements[key] && (elements[key].textContent = this.string(key)));
					[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + 'Theme'));
				}
                toggleCustom() {
                    const isCustom = elements.mapCriteria.value === 'custom';
                    elements.customCriteriaInputs.classList.toggle('hidden', !isCustom);
                }

                toggleCustomCalc() {
                     const isCustom = elements.calcCriteria.value === 'custom';
                     elements.calcCustomCriteriaInputs.classList.toggle('hidden', !isCustom);
                }

                switchTab(tab) {
                    if (tab === 'map') {
                        elements.tabMap.classList.add('active');
                        elements.tabCalc.classList.remove('active');
                        elements.mapView.classList.remove('hidden');
                        elements.calcView.classList.add('hidden');
                        setTimeout(() => this.map.invalidateSize(), 100);
                    } else {
                        elements.tabMap.classList.remove('active');
                        elements.tabCalc.classList.add('active');
                        elements.mapView.classList.add('hidden');
                        elements.calcView.classList.remove('hidden');
                    }
                }

                getCurrentLocation() {
                     if (navigator.geolocation) {
                         navigator.geolocation.getCurrentPosition(
                             (position) => {
                                 elements.calcLat.value = position.coords.latitude.toFixed(4);
                                 elements.calcLon.value = position.coords.longitude.toFixed(4);
                             },
                             (error) => {
                                 alert('Error getting location: ' + error.message);
                             }
                         );
                     } else {
                         alert('Geolocation is not supported by this browser.');
                     }
                }

                calculateDetails() {
                    const lat = parseFloat(elements.calcLat.value);
                    const lon = parseFloat(elements.calcLon.value);
                    const dateStr = elements.calcDate.value;
                    const criteria = elements.calcCriteria.value;

                    if (isNaN(lat) || isNaN(lon) || !dateStr) {
                        alert('Please fill in all fields correctly.');
                        return;
                    }

                    const dateObj = new Date(dateStr + 'T00:00:00Z');
                    const observer = new Astronomy.Observer(lat, lon, 0);
                    const date = Astronomy.MakeTime(dateObj);

                    // 1. Calculate Sunset
                    const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, date.ut, 1);
                    if (!sunset) {
                         elements.results.innerHTML = '<div class="result-card">Error: Sun does not set on this date/location.</div>';
                         return;
                    }

                    // 2. Moon properties at Sunset
                    // Adjust to local time of observer if needed, but Astronomy works in UT.
                    // We need to calculate moon position at the moment of sunset.

                    const sunsetUT = sunset.ut; // This is UT time of sunset
                    const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
                    const moonHor = Astronomy.Horizon(sunsetUT, observer, moonEq.ra, moonEq.dec, 'normal');
                    const sunEq = Astronomy.Equator(Astronomy.Body.Sun, sunsetUT, observer, true, true);
                    const elongation = Astronomy.AngleBetween(sunEq.vec, moonEq.vec);

                    // Calculate Moon Age (Time since New Moon)
                    const prevNewMoon = Astronomy.SearchMoonPhase(0, date.ut, -1);
                    const ageInDays = prevNewMoon ? (sunsetUT - prevNewMoon.ut) : 0;

                    const moonPhase = Astronomy.Illumination(Astronomy.Body.Moon, sunsetUT);

                    // Calculate Moonset after Sunset
                    const moonset = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, sunsetUT, 1);

                    // Format times
                    // We want to show local time relative to the user provided lat/lon or just UT?
                    // The browser's date handling is tricky. Let's just output UT and maybe Local if we can guess offset.
                    // Or just use the browser's timezone since the user is likely in that timezone if using "Use My Location".
                    // But if they input a remote location, browser time is wrong.
                    // Let's stick to showing simple time strings, maybe "HH:MM (UT)" or "HH:MM (Local)" depending on how we format.
                    // Ideally we format to the timezone of the location, but we don't know it without an API.
                    // We'll show UT for clarity or simple HH:MM and let user infer.
                    // Actually, Astronomy.js returns UT double.

                    const fmt = (ut) => {
                        // Convert UT double to Date object
                        if (!ut) return 'N/A';
                        const d = ut.date;
                        // Format to string.
                        // Let's use simple UTC string for now.
                        return d.toISOString().substring(11, 19) + ' UTC';
                    };

                    // Visibility Check
                    let minAlt = 0, minElong = 0, isGIC = false;
                    let customMinAlt = parseFloat(elements.calcMinAlt.value) || 0;
                    let customMinElong = parseFloat(elements.calcMinElong.value) || 0;

                    if (criteria === 'mabbims') { minAlt = 3; minElong = 6.4; }
                    else if (criteria === 'gic') { minAlt = 5; minElong = 8; isGIC = true; }
                    else if (criteria === 'alt0') { minAlt = 0; minElong = -100; }
                    else if (criteria === 'custom') {
                        minAlt = customMinAlt;
                        minElong = customMinElong;
                    }

                    let visible = false;
                    let visibleStatus = this.string('notVisible');
                    let color = 'var(--danger)';
                    let bg = 'var(--on-danger)';

                     // GIC check: sunset must be before 12AM UTC? No, "before midnight".
                     // The logic in map says: if (sunsetUT >= (date.ut + 0.5)) isVisibleGIC = false;
                     // date.ut is noon. +0.5 is midnight next day?
                     // Wait, MakeTime(Date) -> if Date is "YYYY-MM-DDT12:00:00Z", then date.ut is that time.
                     // The condition seems to check if sunset is later than midnight of that day?
                     // I will copy the logic from map.

                     let isVisibleGIC = true;
                     if (isGIC) {
                         // Original logic: if (sunsetUT >= (date.ut + 0.5)) isVisibleGIC = false;
                         // date was created from noon. +0.5 is midnight.
                         if (sunsetUT >= (date.ut + 0.5)) isVisibleGIC = false;
                     }

                     if (isVisibleGIC) {
                         if (moonHor.altitude >= minAlt) {
                             if (elongation >= minElong) {
                                 visible = true;
                             }
                         }
                     }

                     if (visible) {
                         visibleStatus = this.string('visible');
                         color = 'var(--success)';
                         bg = 'var(--on-success)';
                     }

                    const displayData = [
                        { label: 'visibilityStatus', value: visibleStatus, color: color, bg: bg },
                        { label: 'sunsetTime', value: fmt(sunset) },
                        { label: 'moonsetTime', value: fmt(moonset) },
                        { label: 'moonAlt', value: moonHor.altitude.toFixed(2) + '¬∞' },
                        { label: 'moonElong', value: elongation.toFixed(2) + '¬∞' },
                        { label: 'moonAzimuth', value: moonHor.azimuth.toFixed(2) + '¬∞' },
                        { label: 'moonAge', value: ageInDays.toFixed(2) + ' days' },
                        { label: 'illuminatedFraction', value: (moonPhase.phase_fraction * 100).toFixed(2) + '%' }
                    ];

                    let html = '';
                    displayData.forEach(item => {
                         const style = item.color ? `color: ${item.color};` : '';
                         const label = this.string(item.label) || item.label;
                         html += `<div class="result-card">
                                    <div class="result-label">${label}</div>
                                    <div class="result-value" style="${style}">${item.value}</div>
                                  </div>`;
                    });

                    elements.results.innerHTML = html;
                }

                handleRegionChange() {
                    const region = elements.mapRegion.value;
                    if (region === 'indonesia') {
                        this.map.setView([-2.5, 118], 5);
                    } else {
                        this.map.setView([0, 0], 2);
                    }
                }

                handleRenderClick() {
                    if (this.isRendering) {
                        this.worker.terminate();
                        this.worker = new Worker(this.workerUrl);
                        this.worker.onmessage = (e) => this.handleWorkerMessage(e);

                        this.isRendering = false;
                        elements.renderMap.disabled = false;
                        elements.mapStatus.textContent = 'Cancelled.';
                    } else {
                        this.startRender();
                    }
                }

                startRender() {
                    this.isRendering = true;
                    elements.renderMap.disabled = false; // Allow cancelling
                    elements.renderMap.textContent = 'Cancel';
                    elements.mapStatus.textContent = 'Calculating...';

                    const mapBounds = this.map.getBounds();
                    const bounds = {
                        minLat: Math.max(-85, mapBounds.getSouth()),
                        maxLat: Math.min(85, mapBounds.getNorth()),
                        minLon: mapBounds.getWest(),
                        maxLon: mapBounds.getEast()
                    };

                    const criteria = elements.mapCriteria.value;
                    const dateStr = elements.mapDate.value;
                    const dateObj = new Date(dateStr ? dateStr + 'T12:00:00Z' : new Date());

                    const mapSize = this.map.getSize();
                    const widthDeg = bounds.maxLon - bounds.minLon;
                    const heightDeg = bounds.maxLat - bounds.minLat;

                    this.lastBounds = bounds;

                    this.worker.postMessage({
                        bounds: bounds,
                        widthDeg: widthDeg,
                        heightDeg: heightDeg,
                        mapSizeX: mapSize.x,
                        criteria: criteria,
                        dateTimestamp: dateObj.getTime(),
                        minAlt: parseFloat(elements.minAlt.value) || 0,
                        minElong: parseFloat(elements.minElong.value) || 0
                    });
                }

                handleWorkerMessage(e) {
                    const { status, percent, imageData: unused, buffer, width, height, message } = e.data;

                    if (status === 'progress') {
                        elements.mapStatus.textContent = `Calculating... ${percent}%`;
                    } else if (status === 'complete') {
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        const imageData = new ImageData(buffer, width, height);
                        ctx.putImageData(imageData, 0, 0);

                        this.updateOverlay(canvas.toDataURL(), this.lastBounds);

                        this.isRendering = false;
                        elements.renderMap.disabled = false;
                        elements.renderMap.textContent = this.string('renderMap');
                        elements.mapStatus.textContent = 'Done.';
                    } else if (status === 'error') {
                        console.error('Worker Error:', message);
                        elements.mapStatus.textContent = 'Error: ' + message;
                        this.isRendering = false;
                        elements.renderMap.disabled = false;
                        elements.renderMap.textContent = this.string('renderMap');
                    }
                }

                updateOverlay(imageUrl, bounds) {
                    if (this.overlayLayer) {
                        this.map.removeLayer(this.overlayLayer);
                    }
                    const imageBounds = [[bounds.minLat, bounds.minLon], [bounds.maxLat, bounds.maxLon]];
                    this.overlayLayer = L.imageOverlay(imageUrl, imageBounds).addTo(this.map);
                }
			}
			new VisibilityMap();
		</script>
	</body>
</html>
