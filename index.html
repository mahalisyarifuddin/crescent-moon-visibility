<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>Hilal Visibility Map</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
		<style>

:root { --primary: #005dac; --on-primary: #ffffff; --hover: #00539a; --background: #f9f9ff; --surface: #ffffff; --text: #181c21; --border: #c1c6d4; --muted: #f2f3fc; --success: #0b6b1d; --on-success: #ffffff; --danger: #ba1a1a; --on-danger: #ffffff; --highlight-bg: #d4e3ff; }
@media (prefers-color-scheme: dark) { :root:not(.light) { --primary: #a5c8ff; --on-primary: #00315f; --hover: #72adff; --background: #101319; --surface: #0b0e14; --text: #e0e2ea; --border: #414752; --muted: #181c21; --success: #82db7e; --on-success: #00390a; --danger: #ffb4ab; --on-danger: #93000a; --highlight-bg: #001c3a; } }
:root.dark { --primary: #a5c8ff; --on-primary: #00315f; --hover: #72adff; --background: #101319; --surface: #0b0e14; --text: #e0e2ea; --border: #414752; --muted: #181c21; --success: #82db7e; --on-success: #00390a; --danger: #ffb4ab; --on-danger: #93000a; --highlight-bg: #001c3a; }
* { box-sizing: border-box; margin: 0; padding: 0; outline-offset: 2px; }
*:focus-visible { outline: 2px solid var(--primary); }
body { background: var(--background); color: var(--text); font-family: sans-serif; display: flex; justify-content: center; min-height: 100vh; padding: 1rem; }
.container { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; max-width: 1200px; padding: 2rem; width: 100%; position: relative; margin: 2rem 0; display: flex; flex-direction: column; }
.hidden { display: none !important; }
h1, h2, h3, label { margin: .5rem 0; }
label { display: block; font-weight: 700; }
input, select, button { background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 1rem; padding: .5rem; width: 100%; }
button { cursor: pointer; }
button:disabled { opacity: .6; cursor: not-allowed; }
.primary { background: var(--primary); color: var(--on-primary); border: 0; }
.primary:hover:not(:disabled) { background: var(--hover); }
.secondary:hover:not(:disabled) { background: var(--muted); }
.selectors { position: absolute; right: 2rem; top: 1rem; display: flex; gap: 8px; z-index: 1000; }
.row { display: flex; gap: 1rem; margin-bottom: 1rem; }
.group { flex: 1; }
.info { font-size: .9rem; opacity: .8; line-height: 1.6; }
#map { width: 100%; height: 500px; border: 1px solid var(--border); border-radius: 4px; margin-top: 1rem; }
@media(max-width: 768px) { .selectors { position: static; justify-content: end; margin-bottom: .5rem; } .row { flex-direction: column; } #map { height: 350px; } }

		</style>
	</head>
	<body>
		<div class="container">
            <div class="selectors">
				<select id="language">
					<option value="en">English</option>
					<option value="id">Bahasa Indonesia</option>
				</select>
				<select id="theme">
					<option value="auto">Auto</option>
					<option value="light">Light</option>
					<option value="dark">Dark</option>
				</select>
			</div>

            <h1 id="mapTitle">Hilal Visibility Map</h1>

            <div id="controls">
                <div class="row">
                    <div class="group">
                        <label id="dateLabel" for="mapDate">Date</label>
                        <input type="date" id="mapDate">
                    </div>
                    <div class="group">
                        <label id="regionLabel" for="mapRegion">Region</label>
                        <select id="mapRegion">
                            <option value="indonesia">Indonesia</option>
                            <option value="world">World</option>
                        </select>
                    </div>
                    <div class="group">
                        <label id="criteriaLabel" for="mapCriteria">Criteria</label>
                        <select id="mapCriteria">
                            <option value="mabbims">MABBIMS (Alt≥3°, Elong≥6.4°)</option>
                            <option value="gic">Global Islamic (Alt≥5°, Elong≥8°, <12am UTC)</option>
                            <option value="alt0">Altitude > 0°</option>
                            <option value="custom">Custom Criteria</option>
                        </select>
                    </div>
                </div>

                <div class="row hidden" id="customCriteriaInputs">
                    <div class="group">
                        <label id="minAltLabel" for="minAlt">Min Altitude (°)</label>
                        <input type="number" id="minAlt" value="0" step="0.1">
                    </div>
                    <div class="group">
                        <label id="minElongLabel" for="minElong">Min Elongation (°)</label>
                        <input type="number" id="minElong" value="0" step="0.1">
                    </div>
                </div>

                <div class="row">
                    <button id="renderMap" class="primary">Render Map</button>
                </div>
            </div>

            <div id="mapStatus" class="info" style="font-style:italic; min-height: 1.2em;"></div>
            <div id="map"></div>

            <div id="mapLegend" class="info" style="margin-top:0.5rem">
                <span style="display:inline-block;width:12px;height:12px;background:rgba(0, 255, 0, 0.5);margin-right:4px;border:1px solid green"></span><span id="legendVisible">Visible</span>
            </div>

		</div>

        <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

		<script>
			const text = {
				en: {
					autoTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
                    mapTitle: 'Hilal Visibility Map',
                    renderMap: 'Render Map',
                    dateLabel: 'Date',
                    regionLabel: 'Region',
                    criteriaLabel: 'Criteria',
                    legendVisible: 'Visible',
                    minAltLabel: 'Min Altitude (°)',
                    minElongLabel: 'Min Elongation (°)',
                    languageLabel: 'Language',
					themeLabel: 'Theme'
				},
				id: {
					autoTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
                    mapTitle: 'Peta Visibilitas Hilal',
                    renderMap: 'Render Peta',
                    dateLabel: 'Tanggal',
                    regionLabel: 'Wilayah',
                    criteriaLabel: 'Kriteria',
                    legendVisible: 'Terlihat',
                    minAltLabel: 'Min Tinggi (°)',
                    minElongLabel: 'Min Elongasi (°)',
                    languageLabel: 'Bahasa',
					themeLabel: 'Tema'
				}
			};
			const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });

			class VisibilityMap {
				constructor() {
					this.setup();
					this.theme('auto');
					this.lang(navigator.language?.startsWith('id') ? 'id' : 'en');
				}
				setup() {
					elements.language.onchange = event => this.lang(event.target.value);
					elements.theme.onchange = event => this.theme(event.target.value);
                    elements.renderMap.onclick = () => this.handleRenderClick();
                    elements.mapCriteria.onchange = () => this.toggleCustom();
                    elements.mapRegion.onchange = () => this.handleRegionChange();

                    elements.mapDate.valueAsDate = new Date();

                    this.map = L.map('map').setView([-2.5, 118], 5);
                    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }).addTo(this.map);

                    this.overlayLayer = null;
                    this.isRendering = false;
                    this.cancelRender = false;
				}
				string(key) {
					return text[this.language]?.[key] ?? key;
				}
				theme(themeName) {
					document.documentElement.className = themeName === 'auto' ? '' : themeName;
					elements.theme.value = themeName;
				}
				lang(language) {
					this.language = elements.language.value = document.documentElement.lang = language;
					Object.keys(text.en).forEach(key => elements[key] && (elements[key].textContent = this.string(key)));
					[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + 'Theme'));
				}
                toggleCustom() {
                    const isCustom = elements.mapCriteria.value === 'custom';
                    elements.customCriteriaInputs.classList.toggle('hidden', !isCustom);
                }

                handleRegionChange() {
                    const region = elements.mapRegion.value;
                    if (region === 'indonesia') {
                        this.map.setView([-2.5, 118], 5);
                    } else {
                        this.map.setView([0, 0], 2);
                    }
                }

                handleRenderClick() {
                    if (this.isRendering) {
                        this.cancelRender = true;
                        setTimeout(() => this.startRender(), 100);
                    } else {
                        this.startRender();
                    }
                }

                startRender() {
                    this.cancelRender = false;
                    this.isRendering = true;
                    elements.renderMap.disabled = true;
                    elements.mapStatus.textContent = 'Calculating...';

                    // Use current map bounds for rendering
                    const mapBounds = this.map.getBounds();
                    const bounds = {
                        minLat: Math.max(-85, mapBounds.getSouth()),
                        maxLat: Math.min(85, mapBounds.getNorth()),
                        minLon: mapBounds.getWest(),
                        maxLon: mapBounds.getEast()
                    };

                    const criteria = elements.mapCriteria.value;
                    const dateStr = elements.mapDate.value;

                    const dateObj = new Date(dateStr ? dateStr + 'T12:00:00Z' : new Date());
                    let date;
                    try {
                        date = Astronomy.MakeTime(dateObj);
                    } catch (e) {
                        elements.mapStatus.textContent = 'Error: Invalid Date';
                        elements.renderMap.disabled = false;
                        this.isRendering = false;
                        return;
                    }

                    let minAlt = 0, minElong = 0, isGIC = false;
                    if (criteria === 'mabbims') { minAlt = 3; minElong = 6.4; }
                    else if (criteria === 'gic') { minAlt = 5; minElong = 8; isGIC = true; }
                    else if (criteria === 'alt0') { minAlt = 0; minElong = -100; }
                    else if (criteria === 'custom') {
                        minAlt = parseFloat(elements.minAlt.value) || 0;
                        minElong = parseFloat(elements.minElong.value) || 0;
                    }

                    // Calculate PPD based on screen resolution and zoom
                    const mapSize = this.map.getSize();
                    const widthDeg = bounds.maxLon - bounds.minLon;
                    const heightDeg = bounds.maxLat - bounds.minLat;

                    // Match canvas pixels to screen pixels roughly
                    const PPD = mapSize.x / widthDeg;

                    const width = Math.ceil(widthDeg * PPD);
                    const height = Math.ceil(heightDeg * PPD);

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, width, height);
                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    const totalPixels = width * height;

                    let pixelIndex = 0;
                    const chunkSize = 500;
                    // Optimization: Reuse observer and interpolate sunset time
                    const observer = new Astronomy.Observer(0, 0, 0);
                    let currentY = -1;
                    let sunsetBase = null;

                    // Interpolation variables
                    const INTERP_STEP = 10;
                    let prevRA, prevDec, nextRA, nextDec;

                    const processChunk = () => {
                        if (this.cancelRender) {
                            this.isRendering = false;
                            elements.renderMap.disabled = false;
                            elements.mapStatus.textContent = 'Cancelled.';
                            return;
                        }

                        const end = Math.min(pixelIndex + chunkSize, totalPixels);

                        try {
                            for (; pixelIndex < end; pixelIndex++) {
                                const x = pixelIndex % width;
                                const y = Math.floor(pixelIndex / width);
                                const lat = bounds.maxLat - (y / PPD);
                                const lon = bounds.minLon + (x / PPD);

                                if (y !== currentY) {
                                    currentY = y;
                                    observer.latitude = lat;
                                    observer.longitude = 0;
                                    const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, 1, date.ut, 1);
                                    sunsetBase = sunset ? sunset.ut : null;
                                    // Reset interpolation state on new row
                                    prevRA = undefined;
                                }

                                if (sunsetBase !== null) {
                                    observer.latitude = lat;
                                    observer.longitude = lon;

                                    // Optimization: Sunset time is linearly related to longitude for a given latitude
                                    const sunsetUT = sunsetBase - (lon / 360.0);
                                    let moonRA, moonDec;

                                    // Optimization: Interpolate Moon Coordinates (Equator)
                                    // The Moon moves slowly (~0.5 deg/hr), so we can interpolate RA/Dec
                                    // every INTERP_STEP pixels instead of calculating heavy Equator() every pixel.
                                    const xMod = x % INTERP_STEP;

                                    if (xMod === 0 || prevRA === undefined) {
                                        // Keyframe: Calculate exact
                                        const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
                                        prevRA = moonEq.ra;
                                        prevDec = moonEq.dec;

                                        // Calculate next keyframe for interpolation
                                        let nextX = x + INTERP_STEP;
                                        if (nextX >= width) nextX = width - 1;

                                        if (nextX > x) {
                                            const nextLon = bounds.minLon + (nextX / PPD);
                                            const nextSunsetUT = sunsetBase - (nextLon / 360.0);
                                            observer.longitude = nextLon;
                                            const nextMoonEq = Astronomy.Equator(Astronomy.Body.Moon, nextSunsetUT, observer, true, true);
                                            nextRA = nextMoonEq.ra;
                                            nextDec = nextMoonEq.dec;

                                            // Handle RA wrap around (0-24h)
                                            if (Math.abs(nextRA - prevRA) > 12) {
                                                if (nextRA > prevRA) prevRA += 24;
                                                else nextRA += 24;
                                            }
                                            observer.longitude = lon; // restore
                                        } else {
                                            nextRA = prevRA;
                                            nextDec = prevDec;
                                        }

                                        moonRA = prevRA;
                                        moonDec = prevDec;
                                    } else {
                                        // Interpolate
                                        const fraction = xMod / INTERP_STEP;
                                        moonRA = prevRA + (nextRA - prevRA) * fraction;
                                        moonDec = prevDec + (nextDec - prevDec) * fraction;
                                        if (moonRA >= 24) moonRA -= 24;
                                    }

                                    const visible = this.checkVisibility(observer, sunsetUT, minAlt, minElong, isGIC, date.ut, moonRA, moonDec);

                                    if (visible) {
                                        const idx = pixelIndex * 4;
                                        data[idx] = 0; data[idx+1] = 255; data[idx+2] = 0; data[idx+3] = 128;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error in calculation loop:', e);
                            this.isRendering = false;
                            elements.renderMap.disabled = false;
                            elements.mapStatus.textContent = 'Error: ' + e.message;
                            return;
                        }

                        if (pixelIndex % (chunkSize * 5) === 0) {
                             elements.mapStatus.textContent = `Calculating... ${Math.round(pixelIndex/totalPixels*100)}%`;
                        }

                        if (pixelIndex < totalPixels) {
                            requestAnimationFrame(processChunk);
                        } else {
                            ctx.putImageData(imageData, 0, 0);
                            this.updateOverlay(canvas.toDataURL(), bounds);

                            this.isRendering = false;
                            elements.renderMap.disabled = false;
                            elements.mapStatus.textContent = 'Done.';
                        }
                    };
                    requestAnimationFrame(processChunk);
                }

                updateOverlay(imageUrl, bounds) {
                    if (this.overlayLayer) {
                        this.map.removeLayer(this.overlayLayer);
                    }
                    const imageBounds = [[bounds.minLat, bounds.minLon], [bounds.maxLat, bounds.maxLon]];
                    this.overlayLayer = L.imageOverlay(imageUrl, imageBounds).addTo(this.map);
                }

                checkVisibility(observer, sunsetUT, minAlt, minElong, isGIC, baseDateUT, moonRA, moonDec) {
                    if (isGIC) {
                        if (sunsetUT >= (baseDateUT + 0.5)) return false;
                    }

                    // Use passed interpolated/calculated RA/Dec if available, otherwise calculate
                    let ra = moonRA;
                    let dec = moonDec;
                    if (ra === undefined) {
                        const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
                        ra = moonEq.ra;
                        dec = moonEq.dec;
                    }

                    // Optimization: Calculate Altitude first as it's cheaper/more likely to fail than AngleFromSun
                    // We must calculate Horizon every pixel because it depends heavily on LST (which changes with longitude/time)
                    const moonHor = Astronomy.Horizon(sunsetUT, observer, ra, dec, 'normal');
                    const alt = moonHor.altitude;

                    if (alt < minAlt) return false;

                    const elong = Astronomy.AngleFromSun(Astronomy.Body.Moon, sunsetUT);

                    return (elong >= minElong);
                }
			}
			new VisibilityMap();
		</script>
	</body>
</html>
