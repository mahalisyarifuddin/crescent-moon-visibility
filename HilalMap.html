<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Hilal Visibility Map</title>
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--highlight-bg: #d4e3ff;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--highlight-bg: #001c3a;
		}
		* { 
			box-sizing: border-box; 
			margin: 0; 
			padding: 0; 
			outline-offset: 2px; 
		}
		*:focus-visible { 
			outline: 2px solid var(--primary); 
		}
		body {
			background: var(--background);
			color: var(--text);
			font-family: sans-serif;
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 1200px;
			padding: 2rem;
			width: 100%;
			position: relative;
			margin: 2rem 0;
			display: flex;
			flex-direction: column;
		}
		.hidden { 
			display: none !important; 
		}
		h1, h2, h3, label { 
			margin: .5rem 0; 
		}
		label { 
			display: block; 
			font-weight: 700; 
		}
		input, select, button {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font-size: 1rem;
			padding: .5rem;
			width: 100%;
		}
		button { 
			cursor: pointer; 
		}
		button:disabled { 
			opacity: .6; 
			cursor: not-allowed; 
		}
		.primary { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
		}
		.primary:hover:not(:disabled) { 
			background: var(--hover); 
		}
		.secondary:hover:not(:disabled) { 
			background: var(--muted); 
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
			z-index: 1000;
		}
		.row { 
			display: flex; 
			gap: 1rem; 
			margin-bottom: 1rem; 
		}
		.group { 
			flex: 1; 
		}
		.info { 
			font-size: .9rem; 
			opacity: .8; 
			line-height: 1.6; 
		}
		#map { 
			width: 100%; 
			height: 500px; 
			border: 1px solid var(--border); 
			border-radius: 4px; 
			margin-top: 1rem; 
		}
		.tabs { 
			display: flex; 
			border-bottom: 1px solid var(--border); 
			margin-bottom: 1rem; 
		}
		.tab {
			background: transparent;
			border: none;
			border-bottom: 3px solid transparent;
			border-radius: 0;
			cursor: pointer;
			padding: 0.5rem 1rem;
			font-weight: 600;
			color: var(--text);
			opacity: 0.6;
			width: auto;
		}
		.tab:hover { 
			background: var(--muted); 
			opacity: 1; 
		}
		.tab.active { 
			border-bottom-color: var(--primary); 
			opacity: 1; 
		}
		#results { 
			margin-top: 1rem; 
			display: grid; 
			grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
			gap: 1rem; 
		}
		.result-card {
			background: var(--surface);
			padding: 1rem;
			border-radius: 4px;
			border: 1px solid var(--border);
			box-shadow: 0 1px 3px rgba(0,0,0,0.05);
		}
		.result-label { 
			font-size: 0.8rem; 
			opacity: 0.8; 
			margin-bottom: 0.25rem; 
		}
		.result-value { 
			font-size: 1.2rem; 
			font-weight: bold; 
		}
		@media(max-width: 768px) {
			.selectors { 
				position: static; 
				justify-content: end; 
				margin-bottom: .5rem; 
			}
			.row { 
				flex-direction: column; 
			}
			#map { 
				height: 350px; 
			}
		}
		.spinner {
			display: inline-block;
			width: 1em;
			height: 1em;
			border: 2px solid currentColor;
			border-right-color: transparent;
			border-radius: 50%;
			animation: spin 0.75s linear infinite;
			vertical-align: text-bottom;
			margin-right: 4px;
		}
		@keyframes spin { 
			100% { 
				transform: rotate(360deg); 
			} 
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="selectors">
			<select id="language"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
			<select id="theme"><option value="auto">Auto</option><option value="light">Light</option><option value="dark">Dark</option></select>
		</div>
		<h1 id="mapTitle">Hilal Visibility Map</h1>
		<div class="tabs">
			<button id="tabMap" class="tab active">Map</button>
			<button id="tabCalc" class="tab">Detailed Calculations</button>
		</div>
		<div id="mapView">
			<div id="controls">
				<div class="row">
					<div class="group">
						<label id="dateLabel" for="mapDate">Date</label>
						<input type="date" id="mapDate">
					</div>
					<div class="group">
						<label id="regionLabel" for="mapRegion">Region</label>
						<select id="mapRegion"><option value="indonesia">Indonesia</option><option value="world">World</option></select>
					</div>
					<div class="group">
						<label id="criteriaLabel" for="mapCriteria">Criteria</label>
						<select id="mapCriteria">
							<option value="mabbims">MABBIMS (Alt‚â•3¬∞, Elong‚â•6.4¬∞)</option>
							<option value="gic">Global Islamic (Alt‚â•5¬∞, Elong‚â•8¬∞, <12am UTC)</option>
							<option value="alt0">Altitude > 0¬∞</option>
							<option value="custom">Custom Criteria</option>
						</select>
					</div>
				</div>
				<div class="row hidden" id="customCriteriaInputs">
					<div class="group">
						<label id="minAltLabel" for="minAlt">Min Altitude (¬∞)</label>
						<input type="number" id="minAlt" value="0" step="0.1">
					</div>
					<div class="group">
						<label id="minElongLabel" for="minElong">Min Elongation (¬∞)</label>
						<input type="number" id="minElong" value="0" step="0.1">
					</div>
				</div>
				<div class="row">
					<button id="renderMap" class="primary">Render Map</button>
				</div>
			</div>
			<div id="mapStatus" class="info" style="font-style:italic; min-height: 1.2em;"></div>
			<div id="map"></div>
			<div id="mapLegend" class="info" style="margin-top:0.5rem">
				<span style="display:inline-block;width:12px;height:12px;background:rgba(0, 255, 0, 0.5);margin-right:4px;border:1px solid green"></span><span id="legendVisible">Visible</span>
			</div>
		</div>
		<div id="calcView" class="hidden">
			<div class="row">
				<div class="group">
					<label id="calcDateLabel" for="calcDate">Date</label>
					<input type="date" id="calcDate">
				</div>
				<div class="group">
					<label id="calcLatLabel" for="calcLat">Latitude</label>
					<input type="number" id="calcLat" step="0.0001" placeholder="-6.2000">
				</div>
				<div class="group">
					<label id="calcLonLabel" for="calcLon">Longitude</label>
					<input type="number" id="calcLon" step="0.0001" placeholder="106.8166">
				</div>
				<div class="group">
					<label id="utcOffsetLabel" for="calcUtcOffset">UTC Offset</label>
					<input type="number" id="calcUtcOffset" step="0.5" value="0" placeholder="e.g. 7">
				</div>
			</div>
			<div class="row" style="align-items: flex-end;">
				<div class="group">
					<label id="calcCriteriaLabel" for="calcCriteria">Criteria</label>
					<select id="calcCriteria">
						<option value="mabbims">MABBIMS</option>
						<option value="gic">Global Islamic</option>
						<option value="alt0">Altitude > 0¬∞</option>
						<option value="custom">Custom</option>
					</select>
				</div>
				<div class="group">
					<button id="getLocation" class="secondary">üìç Use My Location</button>
				</div>
			</div>
			<div class="row hidden" id="calcCustomCriteriaInputs">
				<div class="group">
					<label for="calcMinAlt">Min Altitude (¬∞)</label>
					<input type="number" id="calcMinAlt" value="0" step="0.1">
				</div>
				<div class="group">
					<label for="calcMinElong">Min Elongation (¬∞)</label>
					<input type="number" id="calcMinElong" value="0" step="0.1">
				</div>
			</div>
			<div class="row">
				<button id="calculateBtn" class="primary">Calculate</button>
			</div>
			<div id="results"></div>
		</div>
	</div>
	<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
	<script>
		const text = {
			en: {
				locating: 'Locating...',
				calculating: 'Calculating...',
				utcOffsetLabel: 'UTC Offset',
				autoTheme: 'Auto Theme',
				lightTheme: 'Light',
				darkTheme: 'Dark',
				mapTitle: 'Hilal Visibility Map',
				renderMap: 'Render Map',
				dateLabel: 'Date',
				regionLabel: 'Region',
				criteriaLabel: 'Criteria',
				legendVisible: 'Visible',
				minAltLabel: 'Min Altitude (¬∞)',
				minElongLabel: 'Min Elongation (¬∞)',
				languageLabel: 'Language',
				themeLabel: 'Theme',
				calcDateLabel: 'Date',
				calcLatLabel: 'Latitude',
				calcLonLabel: 'Longitude',
				calcCriteriaLabel: 'Criteria',
				calculateBtn: 'Calculate',
				tabMap: 'Map',
				tabCalc: 'Detailed Calculations',
				getLocation: 'üìç Use My Location',
				sunsetTime: 'Sunset Time',
				moonsetTime: 'Moonset Time',
				moonAge: 'Moon Age',
				moonAlt: 'Moon Altitude',
				moonElong: 'Elongation',
				moonAzimuth: 'Moon Azimuth',
				moonWidth: 'Moon Width',
				illuminatedFraction: 'Illuminated Fraction',
				visibilityStatus: 'Visibility Status',
				visible: 'Visible',
				notVisible: 'Not Visible',
				regionIndonesia: 'Indonesia',
				regionWorld: 'World',
				criteriaMabbims: 'MABBIMS (Alt‚â•3¬∞, Elong‚â•6.4¬∞)',
				criteriaGic: 'Global Islamic (Alt‚â•5¬∞, Elong‚â•8¬∞, <12am UTC)',
				criteriaAlt0: 'Altitude > 0¬∞',
				criteriaCustom: 'Custom Criteria',
				statusCancelled: 'Cancelled.',
				statusDone: 'Done.',
				statusError: 'Error: ',
				cancel: 'Cancel'
			},
			id: {
				locating: 'Mencari lokasi...',
				calculating: 'Menghitung...',
				utcOffsetLabel: 'Selisih UTC',
				autoTheme: 'Tema Otomatis',
				lightTheme: 'Terang',
				darkTheme: 'Gelap',
				mapTitle: 'Peta Visibilitas Hilal',
				renderMap: 'Render Peta',
				dateLabel: 'Tanggal',
				regionLabel: 'Wilayah',
				criteriaLabel: 'Kriteria',
				legendVisible: 'Terlihat',
				minAltLabel: 'Min Tinggi (¬∞)',
				minElongLabel: 'Min Elongasi (¬∞)',
				languageLabel: 'Bahasa',
				themeLabel: 'Tema',
				calcDateLabel: 'Tanggal',
				calcLatLabel: 'Lintang',
				calcLonLabel: 'Bujur',
				calcCriteriaLabel: 'Kriteria',
				calculateBtn: 'Hitung',
				tabMap: 'Peta',
				tabCalc: 'Hitung Detail',
				getLocation: 'üìç Lokasi Saya',
				sunsetTime: 'Waktu Matahari Terbenam',
				moonsetTime: 'Waktu Bulan Terbenam',
				moonAge: 'Umur Bulan',
				moonAlt: 'Tinggi Bulan',
				moonElong: 'Elongasi',
				moonAzimuth: 'Azimuth Bulan',
				moonWidth: 'Lebar Bulan',
				illuminatedFraction: 'Fraksi Iluminasi',
				visibilityStatus: 'Status Visibilitas',
				visible: 'Terlihat',
				notVisible: 'Tidak Terlihat',
				regionIndonesia: 'Indonesia',
				regionWorld: 'Dunia',
				criteriaMabbims: 'MABBIMS (Alt‚â•3¬∞, Elong‚â•6.4¬∞)',
				criteriaGic: 'Global Islamic (Alt‚â•5¬∞, Elong‚â•8¬∞, <12am UTC)',
				criteriaAlt0: 'Tinggi Bulan > 0¬∞',
				criteriaCustom: 'Kriteria Kustom',
				statusCancelled: 'Dibatalkan.',
				statusDone: 'Selesai.',
				statusError: 'Eror: ',
				cancel: 'Batal'
			}
		};
		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });

		const WORKER_CODE = `
importScripts('https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js');
self.onmessage = function(e) {
	try {
		const { bounds, widthDeg, heightDeg, mapSizeX, criteria, dateTimestamp, minAlt: criteriaMinAlt, minElong: criteriaMinElong } = e.data;
		const date = Astronomy.MakeTime(new Date(dateTimestamp));
		const criteriaParams =
			(criteria === "mabbims") ? { minAlt: 3, minElong: 6.4, isGIC: false } :
			(criteria === "gic") ? { minAlt: 5, minElong: 8, isGIC: true } :
			(criteria === "alt0") ? { minAlt: 0, minElong: -100, isGIC: false } :
			{ minAlt: criteriaMinAlt, minElong: criteriaMinElong, isGIC: false };
		const { minAlt, minElong, isGIC } = criteriaParams;
		const RESOLUTION_FACTOR = 0.25;
		const INTERP_STEP = 10;
		const PPD = (mapSizeX / widthDeg) * RESOLUTION_FACTOR;
		const width = Math.ceil(widthDeg * PPD);
		const height = Math.ceil(heightDeg * PPD);
		const totalPixels = width * height;
		const buffer = new Uint8ClampedArray(totalPixels * 4);
		const observer = new Astronomy.Observer(0, 0, 0);
		let currentY = -1;
		let sunsetBase = null;
		let prevRA, prevDec, prevElong, prevAlt;
		let nextRA, nextDec, nextElong, nextAlt;
		let cachedNextRA, cachedNextDec, cachedNextElong, cachedNextAlt;
		for (let pixelIndex = 0; pixelIndex < totalPixels; pixelIndex++) {
			const x = pixelIndex % width;
			const y = Math.floor(pixelIndex / width);
			const lat = bounds.maxLat - (y / PPD);
			const lon = bounds.minLon + (x / PPD);
			if (y !== currentY) {
				currentY = y;
				observer.latitude = lat;
				observer.longitude = 0;
				const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, date.ut, 1);
				sunsetBase = sunset ? sunset.ut : null;
				prevRA = undefined;
				cachedNextRA = undefined;
			}
			if (sunsetBase !== null) {
				observer.latitude = lat;
				observer.longitude = lon;
				const sunsetUT = sunsetBase - (lon / 360.0);
				let moonRA, moonDec, moonElong, moonAlt;
				const xMod = x % INTERP_STEP;
				if (xMod === 0 || prevRA === undefined) {
					if (x > 0 && prevRA !== undefined && cachedNextRA !== undefined) {
						prevRA = cachedNextRA;
						prevDec = cachedNextDec;
						prevElong = cachedNextElong;
						prevAlt = cachedNextAlt;
					} else {
						const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
						prevRA = moonEq.ra;
						prevDec = moonEq.dec;
						prevElong = Astronomy.AngleFromSun(Astronomy.Body.Moon, sunsetUT);
						prevAlt = Astronomy.Horizon(sunsetUT, observer, prevRA, prevDec, "normal").altitude;
					}
					let nextX = x + INTERP_STEP;
					if (nextX >= width) nextX = width - 1;
					if (nextX > x) {
						const nextLon = bounds.minLon + (nextX / PPD);
						const nextSunsetUT = sunsetBase - (nextLon / 360.0);
						observer.longitude = nextLon;
						const nextMoonEq = Astronomy.Equator(Astronomy.Body.Moon, nextSunsetUT, observer, true, true);
						cachedNextRA = nextMoonEq.ra;
						cachedNextDec = nextMoonEq.dec;
						cachedNextElong = Astronomy.AngleFromSun(Astronomy.Body.Moon, nextSunsetUT);
						cachedNextAlt = Astronomy.Horizon(nextSunsetUT, observer, nextMoonEq.ra, nextMoonEq.dec, "normal").altitude;
						nextRA = cachedNextRA;
						nextDec = cachedNextDec;
						nextElong = cachedNextElong;
						nextAlt = cachedNextAlt;
						if (Math.abs(nextRA - prevRA) > 12) {
							if (nextRA > prevRA) prevRA += 24;
							else nextRA += 24;
						}
						observer.longitude = lon;
					} else {
						nextRA = prevRA;
						nextDec = prevDec;
						nextElong = prevElong;
						nextAlt = prevAlt;
						cachedNextRA = undefined;
					}
					moonRA = prevRA;
					moonDec = prevDec;
					moonElong = prevElong;
					moonAlt = prevAlt;
				} else {
					const fraction = xMod / INTERP_STEP;
					moonRA = prevRA + (nextRA - prevRA) * fraction;
					moonDec = prevDec + (nextDec - prevDec) * fraction;
					moonElong = prevElong + (nextElong - prevElong) * fraction;
					moonAlt = prevAlt + (nextAlt - prevAlt) * fraction;
					if (moonRA >= 24) moonRA -= 24;
				}
				const visible = (!isGIC || sunsetUT < date.ut + 0.5) && moonAlt >= minAlt && moonElong >= minElong;
				if (visible) {
					const idx = pixelIndex * 4;
					buffer[idx] = 0;
					buffer[idx + 1] = 255;
					buffer[idx + 2] = 0;
					buffer[idx + 3] = 128;
				}
			}
		}
		self.postMessage({ buffer, width, height }, [buffer.buffer]);
	} catch (e) {
		self.postMessage({ error: e.message });
	}
};`;

		class HilalMap {
			constructor() {
				this.setup();
				this.theme("auto");
				this.language = navigator.language?.startsWith("id") ? "id" : "en";
				this.lang(this.language);
			}

			setup() {
				elements.language.onchange = event => this.lang(event.target.value);
				elements.theme.onchange = event => this.theme(event.target.value);
				elements.renderMap.onclick = () => this.handleRenderClick();
				elements.mapCriteria.onchange = () => this.toggleCustom();
				elements.mapRegion.onchange = () => this.handleRegionChange();
				elements.tabMap.onclick = () => this.switchTab("map");
				elements.tabCalc.onclick = () => this.switchTab("calc");
				elements.calcCriteria.onchange = () => this.toggleCustomCalc();
				elements.calculateBtn.onclick = () => this.calculateDetails();
				elements.getLocation.onclick = () => this.getCurrentLocation();
				const today = new Date();
				elements.mapDate.valueAsDate = today;
				elements.calcDate.valueAsDate = today;
				this.map = L.map("map").setView([-2.5, 118], 5);
				L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
					maxZoom: 19,
					attribution: "&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>"
				}).addTo(this.map);
				this.overlayLayer = null;
				this.isRendering = false;
			}

			string(key) { return text[this.language]?.[key] ?? key; }

			theme(themeName) {
				document.documentElement.className = themeName === "auto" ? "" : themeName;
				elements.theme.value = themeName;
			}

			lang(language) {
				this.language = elements.language.value = document.documentElement.lang = language;
				Object.keys(text.en).forEach(key => { if (elements[key]) elements[key].textContent = this.string(key); });
				[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + "Theme"));

				const translateOptions = (selectId, prefix) => {
					[...elements[selectId].options].forEach(option => {
						const val = option.value;
						const key = prefix + val.charAt(0).toUpperCase() + val.slice(1);
						option.textContent = this.string(key);
					});
				};
				translateOptions('mapRegion', 'region');
				translateOptions('mapCriteria', 'criteria');
				translateOptions('calcCriteria', 'criteria');
			}

			toggleCustom() {
				const isCustom = elements.mapCriteria.value === "custom";
				elements.customCriteriaInputs.classList.toggle("hidden", !isCustom);
			}

			toggleCustomCalc() {
				const isCustom = elements.calcCriteria.value === "custom";
				elements.calcCustomCriteriaInputs.classList.toggle("hidden", !isCustom);
			}

			switchTab(tab) {
				if (tab === "map") {
					elements.tabMap.classList.add("active");
					elements.tabCalc.classList.remove("active");
					elements.mapView.classList.remove("hidden");
					elements.calcView.classList.add("hidden");
					setTimeout(() => this.map.invalidateSize(), 100);
				} else {
					elements.tabMap.classList.remove("active");
					elements.tabCalc.classList.add("active");
					elements.mapView.classList.add("hidden");
					elements.calcView.classList.remove("hidden");
				}
			}

			getCurrentLocation() {
				const button = elements.getLocation;
				const originalText = button.innerHTML;
				button.disabled = true;
				button.innerHTML = `<span class="spinner"></span> ${this.string("locating")}`;
				if (navigator.geolocation) {
					navigator.geolocation.getCurrentPosition(
						position => {
							const longitude = position.coords.longitude;
							elements.calcLat.value = position.coords.latitude.toFixed(4);
							elements.calcLon.value = longitude.toFixed(4);
							elements.calcUtcOffset.value = Math.round(longitude / 15);
							button.disabled = false;
							button.innerHTML = originalText;
						},
						error => {
							alert("Error getting location: " + error.message);
							button.disabled = false;
							button.innerHTML = originalText;
						}
					);
				} else {
					alert("Geolocation is not supported by this browser.");
					button.disabled = false;
					button.innerHTML = originalText;
				}
			}

			calculateDetails() {
				const latitude = parseFloat(elements.calcLat.value);
				const longitude = parseFloat(elements.calcLon.value);
				const dateString = elements.calcDate.value;
				const criteria = elements.calcCriteria.value;
				if (isNaN(latitude) || isNaN(longitude) || !dateString) alert("Please fill in all fields correctly.");
				else this.calculateDetailsInner(latitude, longitude, dateString, criteria);
			}

			calculateDetailsInner(latitude, longitude, dateString, criteria) {
				const dateObj = new Date(dateString + "T00:00:00Z");
				const observer = new Astronomy.Observer(latitude, longitude, 0);
				const date = Astronomy.MakeTime(dateObj);
				const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, date.ut, 1);
				if (!sunset) {
					elements.results.innerHTML = "<div class=\"result-card\">Error: Sun does not set on this date/location.</div>";
					return;
				}
				this.calculateDetailsWithSunset(sunset, observer, date, criteria);
			}

			calculateDetailsWithSunset(sunset, observer, date, criteria) {
				const sunsetUT = sunset.ut;
				const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
				const moonHor = Astronomy.Horizon(sunsetUT, observer, moonEq.ra, moonEq.dec, "normal");
				const sunEq = Astronomy.Equator(Astronomy.Body.Sun, sunsetUT, observer, true, true);
				const elongation = Astronomy.AngleBetween(sunEq.vec, moonEq.vec);
				const prevNewMoon = Astronomy.SearchMoonPhase(0, date.ut, -1);
				const ageInDays = prevNewMoon ? (sunsetUT - prevNewMoon.ut) : 0;
				const moonPhase = Astronomy.Illumination(Astronomy.Body.Moon, sunsetUT);
				const moonset = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, sunsetUT, 1);
				const offset = parseFloat(elements.calcUtcOffset.value) || 0;
				const formatTime = ut => {
					if (!ut) return "N/A";
					const d = ut.date;
					d.setMinutes(d.getMinutes() + offset * 60);
					const timeString = d.toISOString().substring(11, 19);
					const sign = offset >= 0 ? "+" : "";
					return `${timeString} (UTC${sign}${offset})`;
				};
				const customMinAlt = parseFloat(elements.calcMinAlt.value) || 0;
				const customMinElong = parseFloat(elements.calcMinElong.value) || 0;
				const criteriaParams =
					(criteria === "mabbims") ? { minAlt: 3, minElong: 6.4, isGIC: false } :
					(criteria === "gic") ? { minAlt: 5, minElong: 8, isGIC: true } :
					(criteria === "alt0") ? { minAlt: 0, minElong: -100, isGIC: false } :
					{ minAlt: customMinAlt, minElong: customMinElong, isGIC: false };
				const { minAlt, minElong, isGIC } = criteriaParams;
				const visible = ((!isGIC || sunsetUT < date.ut + 0.5) && moonHor.altitude >= minAlt && elongation >= minElong);
				const visibleStatus = visible ? this.string("visible") : this.string("notVisible");
				const color = visible ? "var(--success)" : "var(--danger)";
				const displayData = [
					{ label: "visibilityStatus", value: visibleStatus, color: color },
					{ label: "sunsetTime", value: formatTime(sunset) },
					{ label: "moonsetTime", value: formatTime(moonset) },
					{ label: "moonAlt", value: moonHor.altitude.toFixed(2) + "¬∞" },
					{ label: "moonElong", value: elongation.toFixed(2) + "¬∞" },
					{ label: "moonAzimuth", value: moonHor.azimuth.toFixed(2) + "¬∞" },
					{ label: "moonAge", value: ageInDays.toFixed(2) + " days" },
					{ label: "illuminatedFraction", value: (moonPhase.phase_fraction * 100).toFixed(2) + "%" }
				];
				let html = "";
				displayData.forEach(item => {
					const style = item.color ? `color: ${item.color};` : "";
					const label = this.string(item.label) || item.label;
					html += `<div class="result-card"><div class="result-label">${label}</div><div class="result-value" style="${style}">${item.value}</div></div>`;
				});
				elements.results.innerHTML = html;
			}

			handleRegionChange() {
				const region = elements.mapRegion.value;
				if (region === "indonesia") this.map.setView([-2.5, 118], 5);
				else this.map.setView([0, 0], 2);
			}

			handleRenderClick() {
				this.isRendering ? this.cancelRender() : this.startRender();
			}

			cancelRender() {
				if (this.worker) {
					this.worker.terminate();
					this.worker = null;
				}
				this.isRendering = false;
				elements.renderMap.disabled = false;
				elements.renderMap.textContent = this.string("renderMap");
				elements.mapStatus.textContent = this.string("statusCancelled");
			}

			startRender() {
				this.isRendering = true;
				elements.renderMap.disabled = false;
				elements.renderMap.textContent = this.string("cancel");
				elements.mapStatus.innerHTML = `<span class="spinner"></span> ${this.string("calculating")}`;
				const mapBounds = this.map.getBounds();
				const bounds = {
					minLat: Math.max(-85, mapBounds.getSouth()),
					maxLat: Math.min(85, mapBounds.getNorth()),
					minLon: mapBounds.getWest(),
					maxLon: mapBounds.getEast()
				};
				const criteria = elements.mapCriteria.value;
				const dateString = elements.mapDate.value;
				const dateObj = new Date(dateString ? dateString + "T12:00:00Z" : new Date());
				const mapSize = this.map.getSize();
				const widthDeg = bounds.maxLon - bounds.minLon;
				const heightDeg = bounds.maxLat - bounds.minLat;
				this.lastBounds = bounds;
				const renderParams = {
					bounds: bounds,
					widthDeg: widthDeg,
					heightDeg: heightDeg,
					mapSizeX: mapSize.x,
					criteria: criteria,
					dateTimestamp: dateObj.getTime(),
					minAlt: parseFloat(elements.minAlt.value) || 0,
					minElong: parseFloat(elements.minElong.value) || 0
				};
				if (!this.worker) {
					const blob = new Blob([WORKER_CODE], { type: 'application/javascript' });
					this.worker = new Worker(URL.createObjectURL(blob));
				}
				this.worker.onmessage = (e) => {
					const data = e.data;
					if (data.buffer) this.handleComplete(data.width, data.height, data.buffer);
					else if (data.error) {
						console.error(data.error);
						elements.mapStatus.textContent = this.string("statusError") + data.error;
						this.cancelRender();
					}
				};
				this.worker.postMessage(renderParams);
			}

			handleComplete(width, height, buffer) {
				const canvas = document.createElement("canvas");
				canvas.width = width;
				canvas.height = height;
				const context = canvas.getContext("2d");
				const imageData = new ImageData(buffer, width, height);
				context.putImageData(imageData, 0, 0);
				this.updateOverlay(canvas.toDataURL(), this.lastBounds);
				this.isRendering = false;
				elements.renderMap.disabled = false;
				elements.renderMap.textContent = this.string("renderMap");
				elements.mapStatus.textContent = this.string("statusDone");
			}

			updateOverlay(imageUrl, bounds) {
				if (this.overlayLayer) this.map.removeLayer(this.overlayLayer);
				const imageBounds = [[bounds.minLat, bounds.minLon], [bounds.maxLat, bounds.maxLon]];
				this.overlayLayer = L.imageOverlay(imageUrl, imageBounds).addTo(this.map);
			}
		}
		new HilalMap();
	</script>
</body>
</html>
