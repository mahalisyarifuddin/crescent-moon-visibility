<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Hilal Visibility Map</title>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--highlight-bg: #d4e3ff;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--highlight-bg: #001c3a;
		}
		* { 
			box-sizing: border-box; 
			margin: 0; 
			padding: 0; 
			outline-offset: 2px; 
		}
		*:focus-visible { 
			outline: 2px solid var(--primary); 
		}
		body {
			background: var(--background);
			color: var(--text);
			font-family: sans-serif;
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 1200px;
			padding: 2rem;
			width: 100%;
			position: relative;
			margin: 2rem 0;
			display: flex;
			flex-direction: column;
		}
		.hidden { 
			display: none !important; 
		}
		h1, h2, h3, label { 
			margin: .5rem 0; 
		}
		label { 
			display: block; 
			font-weight: 700; 
		}
		input, select, button {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font-size: 1rem;
			padding: .5rem;
			width: 100%;
		}
		button { 
			cursor: pointer; 
		}
		button:disabled { 
			opacity: .6; 
			cursor: not-allowed; 
		}
		.primary { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
		}
		.primary:hover:not(:disabled) { 
			background: var(--hover); 
		}
		.secondary:hover:not(:disabled) { 
			background: var(--muted); 
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
			z-index: 1000;
		}
		.row { 
			display: flex; 
			gap: 1rem; 
			margin-bottom: 1rem; 
		}
		.group { 
			flex: 1; 
		}
		.info { 
			font-size: .9rem; 
			opacity: .8; 
			line-height: 1.6; 
		}
		#map-container {
			width: 100%; 
			height: 500px; 
			border: 1px solid var(--border); 
			border-radius: 4px; 
			margin-top: 1rem; 
			position: relative;
			overflow: hidden;
			background: #aadaff;
			cursor: grab;
		}
		#map-container:active {
			cursor: grabbing;
		}
		#map-wrapper {
			position: absolute;
			top: 50%;
			left: 50%;
			transform-origin: center center;
			width: 100%;
			height: 100%;
		}
		#map-image {
			width: 100%;
			height: 100%;
			object-fit: cover;
			display: block;
			user-select: none;
			position: absolute;
			top: 0;
			left: 0;
		}
		#map-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
		}
		.map-controls {
			position: absolute;
			top: 10px;
			right: 10px;
			display: flex;
			flex-direction: column;
			gap: 5px;
			z-index: 10;
		}
		.map-controls button {
			width: 30px;
			height: 30px;
			padding: 0;
			font-size: 18px;
			background: var(--surface);
			border: 1px solid var(--border);
			cursor: pointer;
		}
		.tabs { 
			display: flex; 
			border-bottom: 1px solid var(--border); 
			margin-bottom: 1rem; 
		}
		.tab {
			background: transparent;
			border: none;
			border-bottom: 3px solid transparent;
			border-radius: 0;
			cursor: pointer;
			padding: 0.5rem 1rem;
			font-weight: 600;
			color: var(--text);
			opacity: 0.6;
			width: auto;
		}
		.tab:hover { 
			background: var(--muted); 
			opacity: 1; 
		}
		.tab.active { 
			border-bottom-color: var(--primary); 
			opacity: 1; 
		}
		#results { 
			margin-top: 1rem; 
			display: grid; 
			grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
			gap: 1rem; 
		}
		.result-card {
			background: var(--surface);
			padding: 1rem;
			border-radius: 4px;
			border: 1px solid var(--border);
			box-shadow: 0 1px 3px rgba(0,0,0,0.05);
		}
		.result-label { 
			font-size: 0.8rem; 
			opacity: 0.8; 
			margin-bottom: 0.25rem; 
		}
		.result-value { 
			font-size: 1.2rem; 
			font-weight: bold; 
		}
		@media(max-width: 768px) {
			.selectors { 
				position: static; 
				justify-content: end; 
				margin-bottom: .5rem; 
			}
			.row { 
				flex-direction: column; 
			}
			#map-container {
				height: 350px; 
			}
		}
		.spinner {
			display: inline-block;
			width: 1em;
			height: 1em;
			border: 2px solid currentColor;
			border-right-color: transparent;
			border-radius: 50%;
			animation: spin 0.75s linear infinite;
			vertical-align: text-bottom;
			margin-right: 4px;
		}
		@keyframes spin { 
			100% { 
				transform: rotate(360deg); 
			} 
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="selectors">
			<select id="language"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
			<select id="theme"><option value="auto">Auto</option><option value="light">Light</option><option value="dark">Dark</option></select>
		</div>
		<h1 id="mapTitle">Hilal Visibility Map</h1>
		<div class="tabs">
			<button id="tabMap" class="tab active">Map</button>
			<button id="tabCalc" class="tab">Detailed Calculations</button>
		</div>
		<div id="mapView">
			<div id="controls">
				<div class="row">
					<div class="group">
						<label id="dateLabel" for="mapDate">Date</label>
						<input type="date" id="mapDate">
					</div>
					<div class="group">
						<label id="regionLabel" for="mapRegion">Region</label>
						<select id="mapRegion">
							<option value="world">World</option>
							<option value="indonesia">Indonesia</option>
						</select>
					</div>
					<div class="group">
						<label id="criteriaLabel" for="mapCriteria">Criteria</label>
						<select id="mapCriteria">
							<option value="mabbims">MABIMS (Alt ≥3°, Elong ≥6.4°)</option>
							<option value="gic">GIC (Alt ≥5°, Elong ≥8°)</option>
							<option value="alt0">Altitude ≥0°</option>
							<option value="custom">Custom</option>
						</select>
					</div>
				</div>
				<div id="customCriteriaInputs" class="hidden row">
					<div class="group">
						<label id="minAltLabel" for="minAlt">Min Altitude (degrees)</label>
						<input type="number" id="minAlt" step="0.1" value="3">
					</div>
					<div class="group">
						<label id="minElongLabel" for="minElong">Min Elongation (degrees)</label>
						<input type="number" id="minElong" step="0.1" value="6.4">
					</div>
				</div>
				<button id="renderMap" class="primary">Render Map</button>
				<div id="mapStatus" class="info" style="margin-top: .5rem;"></div>
			</div>
			<div id="map-container">
				<div class="map-controls">
					<button id="zoom-in" title="Zoom In">+</button>
					<button id="zoom-out" title="Zoom Out">−</button>
					<button id="zoom-reset" title="Reset">⟲</button>
				</div>
				<div id="map-wrapper">
					<img id="map-image" src="https://upload.wikimedia.org/wikipedia/commons/f/f4/Mercator_projection_SW.jpg" alt="World Map" draggable="false">
					<canvas id="map-overlay"></canvas>
				</div>
			</div>
		</div>
		<div id="calcView" class="hidden">
			<div class="row">
				<div class="group">
					<label id="calcDateLabel" for="calcDate">Date</label>
					<input type="date" id="calcDate">
				</div>
				<div class="group">
					<label id="latLabel" for="calcLat">Latitude</label>
					<input type="number" id="calcLat" step="0.0001" placeholder="e.g., -6.2088">
				</div>
				<div class="group">
					<label id="lonLabel" for="calcLon">Longitude</label>
					<input type="number" id="calcLon" step="0.0001" placeholder="e.g., 106.8456">
				</div>
			</div>
			<div class="row">
				<div class="group">
					<label id="utcOffsetLabel" for="calcUtcOffset">UTC Offset (hours)</label>
					<input type="number" id="calcUtcOffset" step="1" value="7" placeholder="e.g., 7">
				</div>
				<div class="group">
					<label id="calcCriteriaLabel" for="calcCriteria">Criteria</label>
					<select id="calcCriteria">
						<option value="mabbims">MABIMS</option>
						<option value="gic">GIC</option>
						<option value="alt0">Altitude ≥0°</option>
						<option value="custom">Custom</option>
					</select>
				</div>
			</div>
			<div id="calcCustomCriteriaInputs" class="hidden row">
				<div class="group">
					<label id="calcMinAltLabel" for="calcMinAlt">Min Altitude (degrees)</label>
					<input type="number" id="calcMinAlt" step="0.1" value="3">
				</div>
				<div class="group">
					<label id="calcMinElongLabel" for="calcMinElong">Min Elongation (degrees)</label>
					<input type="number" id="calcMinElong" step="0.1" value="6.4">
				</div>
			</div>
			<div class="row">
				<button id="getLocation" class="secondary">Get Current Location</button>
				<button id="calculateBtn" class="primary">Calculate</button>
			</div>
			<div id="results"></div>
		</div>
	</div>
	<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
	<script>
		const text = {
			en: {
				mapTitle: "Hilal Visibility Map",
				dateLabel: "Date",
				regionLabel: "Region",
				criteriaLabel: "Criteria",
				renderMap: "Render Map",
				calculating: "Calculating...",
				calcDateLabel: "Date",
				latLabel: "Latitude",
				lonLabel: "Longitude",
				utcOffsetLabel: "UTC Offset (hours)",
				calcCriteriaLabel: "Criteria",
				getLocation: "Get Current Location",
				calculateBtn: "Calculate",
				visibilityStatus: "Visibility Status",
				visible: "Visible",
				notVisible: "Not Visible",
				sunsetTime: "Sunset Time",
				moonsetTime: "Moonset Time",
				moonAlt: "Moon Altitude",
				moonElong: "Moon Elongation",
				moonAzimuth: "Moon Azimuth",
				moonAge: "Moon Age",
				illuminatedFraction: "Illuminated Fraction",
				locating: "Locating...",
				autoTheme: "Auto",
				lightTheme: "Light",
				darkTheme: "Dark",
				regionIndonesia: 'Indonesia',
				regionWorld: 'World',
				criteriaMabbims: 'MABBIMS (Alt≥3°, Elong≥6.4°)',
				criteriaGic: 'Global Islamic (Alt≥5°, Elong≥8°)',
				criteriaAlt0: 'Altitude > 0°',
				criteriaCustom: 'Custom Criteria',
				utcPlaceholder: 'e.g., 7',
				done: "Done",
				cancel: "Cancel",
				cancelled: "Cancelled",
				minAltLabel: "Min Altitude (degrees)",
				minElongLabel: "Min Elongation (degrees)",
				calcMinAltLabel: "Min Altitude (degrees)",
				calcMinElongLabel: "Min Elongation (degrees)"
			},
			id: {
				mapTitle: "Peta Visibilitas Hilal",
				dateLabel: "Tanggal",
				regionLabel: "Wilayah",
				criteriaLabel: "Kriteria",
				renderMap: "Render Peta",
				calculating: "Menghitung...",
				calcDateLabel: "Tanggal",
				latLabel: "Lintang",
				lonLabel: "Bujur",
				utcOffsetLabel: "Offset UTC (jam)",
				calcCriteriaLabel: "Kriteria",
				getLocation: "Dapatkan Lokasi Saat Ini",
				calculateBtn: "Hitung",
				visibilityStatus: "Status Visibilitas",
				visible: "Terlihat",
				notVisible: "Tidak Terlihat",
				sunsetTime: "Waktu Maghrib",
				moonsetTime: "Waktu Terbenam Bulan",
				moonAlt: "Ketinggian Bulan",
				moonElong: "Elongasi Bulan",
				moonAzimuth: "Azimuth Bulan",
				moonAge: "Umur Bulan",
				illuminatedFraction: "Fraksi Teriluminasi",
				locating: "Mencari lokasi...",
				autoTheme: "Otomatis",
				lightTheme: "Terang",
				darkTheme: "Gelap",
				regionIndonesia: 'Indonesia',
				regionWorld: 'Dunia',
				criteriaMabbims: 'MABBIMS (Alt≥3°, Elong≥6.4°)',
				criteriaGic: 'Global Islamic (Alt≥5°, Elong≥8°)',
				criteriaAlt0: 'Tinggi Bulan > 0°',
				criteriaCustom: 'Kriteria Kustom',
				utcPlaceholder: 'contoh: 7',
				done: "Selesai",
				cancel: "Batal",
				cancelled: "Dibatalkan",
				minAltLabel: "Min Ketinggian (derajat)",
				minElongLabel: "Min Elongasi (derajat)",
				calcMinAltLabel: "Min Ketinggian (derajat)",
				calcMinElongLabel: "Min Elongasi (derajat)"
			}
		};

		const WORKER_CODE = `
importScripts("https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js");
self.onmessage = function(e) {
	try {
		const params = e.data;
		const {bounds, widthDeg, heightDeg, criteria, dateTimestamp, minAlt, minElong} = params;

		// Optimize grid size - max 245x245 grid for better resolution (target ~20s)
		const maxGridSize = 245;
		const cellSizeDeg = Math.max(widthDeg / maxGridSize, heightDeg / maxGridSize, 0.1);
		const width = Math.min(Math.ceil(widthDeg / cellSizeDeg), maxGridSize);
		const height = Math.min(Math.ceil(heightDeg / cellSizeDeg), maxGridSize);

		const buffer = new Uint8ClampedArray(width * height * 4);
		const dateObj = new Date(dateTimestamp);
		const date = Astronomy.MakeTime(dateObj);
		const criteriaParams =
			(criteria === "mabbims") ? {minAlt: 3, minElong: 6.4, isGIC: false} :
			(criteria === "gic") ? {minAlt: 5, minElong: 8, isGIC: true} :
			(criteria === "alt0") ? {minAlt: 0, minElong: -100, isGIC: false} :
			{minAlt: minAlt, minElong: minElong, isGIC: false};
		const {minAlt: criteriaMinAlt, minElong: criteriaMinElong, isGIC} = criteriaParams;

		// Mercator functions
		const DEG_TO_RAD = Math.PI / 180;
		const RAD_TO_DEG = 180 / Math.PI;
		function latToMercatorY(lat) {
			return Math.log(Math.tan(Math.PI / 4 + (lat * DEG_TO_RAD) / 2));
		}
		function mercatorYToLat(y) {
			return (2 * Math.atan(Math.exp(y)) - Math.PI / 2) * RAD_TO_DEG;
		}

		// Calculate Y range for the bounds using Mercator
		const minY = latToMercatorY(bounds.minLat);
		const maxY = latToMercatorY(bounds.maxLat);
		const yRange = maxY - minY;

		for (let row = 0; row < height; row++) {
			// Calculate latitude for this row (Mercator interpolation)
			// Row 0 is top (maxY), Row height is bottom (minY)
			const normY = row / (height - 1 || 1);
			const mercY = maxY - normY * yRange;
			const lat = mercatorYToLat(mercY);

			for (let col = 0; col < width; col++) {
				const lon = bounds.minLon + (col * cellSizeDeg);
				const observer = new Astronomy.Observer(lat, lon, 0);

				// Adjust start time to approximate local noon for the search
				// date.ut is 12:00 UTC. Subtract lon/15/24 (hours converted to days) to approximate local 12:00 converted to UTC.
				const startUT = date.ut - (lon / 15 / 24);

				const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, startUT, 1);
				let visible = false;
				if (sunset) {
					const sunsetUT = sunset.ut;
					if (!isGIC || sunsetUT < date.ut + 0.5) {
						const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
						const moonHor = Astronomy.Horizon(sunsetUT, observer, moonEq.ra, moonEq.dec, "normal");
						const sunEq = Astronomy.Equator(Astronomy.Body.Sun, sunsetUT, observer, true, true);
						const elongation = Astronomy.AngleBetween(sunEq.vec, moonEq.vec);
						if (moonHor.altitude >= criteriaMinAlt && elongation >= criteriaMinElong) {
							visible = true;
						}
					}
				}
				const idx = (row * width + col) * 4;
				if (visible) {
					buffer[idx] = 0; buffer[idx+1] = 200; buffer[idx+2] = 0; buffer[idx+3] = 180;
				} else {
					buffer[idx] = 255; buffer[idx+1] = 0; buffer[idx+2] = 0; buffer[idx+3] = 180;
				}
			}
			// Report progress every 10 rows
			if (row % 10 === 0) {
				self.postMessage({progress: (row / height * 100).toFixed(0)});
			}
		}
		self.postMessage({width, height, buffer: buffer.buffer}, [buffer.buffer]);
	} catch(err) {
		self.postMessage({error: err.message});
	}
};`;

		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });

		class HilalMap {
			constructor() {
				this.language = "en";
				this.worker = null;
				this.isRendering = false;
				this.setup();
			}

			setup() {
				elements.language.onchange = event => this.lang(event.target.value);
				elements.theme.onchange = event => this.theme(event.target.value);
				elements.renderMap.onclick = () => this.handleRenderClick();
				elements.mapCriteria.onchange = () => this.toggleCustom();
				elements.mapRegion.onchange = () => this.handleRegionChange();
				elements.tabMap.onclick = () => this.switchTab("map");
				elements.tabCalc.onclick = () => this.switchTab("calc");
				elements.calcCriteria.onchange = () => this.toggleCustomCalc();
				elements.calculateBtn.onclick = () => this.calculateDetails();
				elements.getLocation.onclick = () => this.getCurrentLocation();

				// Zoom and pan setup
				this.scale = 1;
				this.translateX = 0;
				this.translateY = 0;
				this.isDragging = false;
				this.startX = 0;
				this.startY = 0;

				elements['zoom-in'].onclick = () => this.zoom(1.2);
				elements['zoom-out'].onclick = () => this.zoom(0.8);
				elements['zoom-reset'].onclick = () => this.resetZoom();

				elements['map-container'].addEventListener('wheel', (e) => {
					e.preventDefault();
					const delta = e.deltaY > 0 ? 0.9 : 1.1;
					this.zoom(delta);
				});

				elements['map-container'].addEventListener('mousedown', (e) => {
					this.isDragging = true;
					this.startX = e.clientX - this.translateX;
					this.startY = e.clientY - this.translateY;
				});

				elements['map-container'].addEventListener('mousemove', (e) => {
					if (!this.isDragging) return;
					this.translateX = e.clientX - this.startX;
					this.translateY = e.clientY - this.startY;
					this.limitPan();
					this.updateTransform();
				});

				elements['map-container'].addEventListener('mouseup', () => {
					this.isDragging = false;
				});

				elements['map-container'].addEventListener('mouseleave', () => {
					this.isDragging = false;
				});

				const today = new Date();
				elements.mapDate.valueAsDate = today;
				elements.calcDate.valueAsDate = today;

				// Setup canvas overlay
				const canvas = elements['map-overlay'];
				const img = elements['map-image'];

				img.onload = () => {
					canvas.width = img.naturalWidth;
					canvas.height = img.naturalHeight;
					this.redrawOverlay();
				};

				window.addEventListener('resize', () => {
					this.redrawOverlay();
				});

				// Initialize to world view
				this.handleRegionChange();
			}

			limitPan() {
				const container = elements['map-container'];
				const wrapper = elements['map-wrapper'];
				const containerWidth = container.offsetWidth;
				const containerHeight = container.offsetHeight;
				const scaledWidth = containerWidth * this.scale;
				const scaledHeight = containerHeight * this.scale;

				// Limit horizontal pan
				const maxX = (scaledWidth - containerWidth) / 2;
				const minX = -maxX;
				this.translateX = Math.max(minX, Math.min(maxX, this.translateX));

				// Limit vertical pan
				const maxY = (scaledHeight - containerHeight) / 2;
				const minY = -maxY;
				this.translateY = Math.max(minY, Math.min(maxY, this.translateY));
			}

			zoom(factor) {
				this.scale = Math.max(0.5, Math.min(5, this.scale * factor));
				this.limitPan();
				this.updateTransform();
			}

			resetZoom() {
				this.scale = 1;
				this.translateX = 0;
				this.translateY = 0;
				this.updateTransform();
			}

			updateTransform() {
				elements['map-wrapper'].style.transform =
					`translate(-50%, -50%) translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
			}

			string(key) { return text[this.language]?.[key] ?? key; }

			theme(themeName) {
				document.documentElement.className = themeName === "auto" ? "" : themeName;
				elements.theme.value = themeName;
			}

			lang(language) {
				this.language = elements.language.value = document.documentElement.lang = language;
				Object.keys(text.en).forEach(key => { if (elements[key]) elements[key].textContent = this.string(key); });
				[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + "Theme"));
				if (elements.calcUtcOffset) elements.calcUtcOffset.placeholder = this.string("utcPlaceholder");

				const translateOptions = (selectId, prefix) => {
					[...elements[selectId].options].forEach(option => {
						const val = option.value;
						const key = prefix + val.charAt(0).toUpperCase() + val.slice(1);
						const translated = this.string(key);
						if (translated !== key) option.textContent = translated;
					});
				};
				translateOptions('mapRegion', 'region');
				translateOptions('mapCriteria', 'criteria');
				translateOptions('calcCriteria', 'criteria');
			}

			toggleCustom() {
				const isCustom = elements.mapCriteria.value === "custom";
				elements.customCriteriaInputs.classList.toggle("hidden", !isCustom);
			}

			toggleCustomCalc() {
				const isCustom = elements.calcCriteria.value === "custom";
				elements.calcCustomCriteriaInputs.classList.toggle("hidden", !isCustom);
			}

			switchTab(tab) {
				if (tab === "map") {
					elements.tabMap.classList.add("active");
					elements.tabCalc.classList.remove("active");
					elements.mapView.classList.remove("hidden");
					elements.calcView.classList.add("hidden");
				} else {
					elements.tabMap.classList.remove("active");
					elements.tabCalc.classList.add("active");
					elements.mapView.classList.add("hidden");
					elements.calcView.classList.remove("hidden");
				}
			}

			getCurrentLocation() {
				const button = elements.getLocation;
				const originalText = button.innerHTML;
				button.disabled = true;
				button.innerHTML = `<span class="spinner"></span> ${this.string("locating")}`;
				if (navigator.geolocation) {
					navigator.geolocation.getCurrentPosition(
						position => {
							const longitude = position.coords.longitude;
							elements.calcLat.value = position.coords.latitude.toFixed(4);
							elements.calcLon.value = longitude.toFixed(4);
							elements.calcUtcOffset.value = Math.round(longitude / 15);
							button.disabled = false;
							button.innerHTML = originalText;
						},
						error => {
							alert("Error getting location: " + error.message);
							button.disabled = false;
							button.innerHTML = originalText;
						}
					);
				} else {
					alert("Geolocation is not supported by this browser.");
					button.disabled = false;
					button.innerHTML = originalText;
				}
			}

			calculateDetails() {
				const latitude = parseFloat(elements.calcLat.value);
				const longitude = parseFloat(elements.calcLon.value);
				const dateString = elements.calcDate.value;
				const criteria = elements.calcCriteria.value;
				if (isNaN(latitude) || isNaN(longitude) || !dateString) alert("Please fill in all fields correctly.");
				else this.calculateDetailsInner(latitude, longitude, dateString, criteria);
			}

			calculateDetailsInner(latitude, longitude, dateString, criteria) {
				const dateObj = new Date(dateString + "T12:00:00Z");
				const observer = new Astronomy.Observer(latitude, longitude, 0);
				const date = Astronomy.MakeTime(dateObj);
				// Adjust start time to approximate local noon
				const startUT = date.ut - (longitude / 15 / 24);
				const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, startUT, 1);
				if (!sunset) {
					elements.results.innerHTML = "<div class=\"result-card\">Error: Sun does not set on this date/location.</div>";
					return;
				}
				this.calculateDetailsWithSunset(sunset, observer, date, criteria);
			}

			calculateDetailsWithSunset(sunset, observer, date, criteria) {
				const sunsetUT = sunset.ut;
				const moonEq = Astronomy.Equator(Astronomy.Body.Moon, sunsetUT, observer, true, true);
				const moonHor = Astronomy.Horizon(sunsetUT, observer, moonEq.ra, moonEq.dec, "normal");
				const sunEq = Astronomy.Equator(Astronomy.Body.Sun, sunsetUT, observer, true, true);
				const elongation = Astronomy.AngleBetween(sunEq.vec, moonEq.vec);
				const prevNewMoon = Astronomy.SearchMoonPhase(0, date.ut, -1);
				const ageInDays = prevNewMoon ? (sunsetUT - prevNewMoon.ut) : 0;
				const moonPhase = Astronomy.Illumination(Astronomy.Body.Moon, sunsetUT);
				const moonset = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, sunsetUT, 1);
				const offset = parseFloat(elements.calcUtcOffset.value) || 0;
				const formatTime = ut => {
					if (!ut) return "N/A";
					const d = ut.date;
					d.setMinutes(d.getMinutes() + offset * 60);
					const timeString = d.toISOString().substring(11, 19);
					const sign = offset >= 0 ? "+" : "";
					return `${timeString} (UTC${sign}${offset})`;
				};
				const customMinAlt = parseFloat(elements.calcMinAlt.value) || 0;
				const customMinElong = parseFloat(elements.calcMinElong.value) || 0;
				const criteriaParams =
					(criteria === "mabbims") ? { minAlt: 3, minElong: 6.4, isGIC: false } :
					(criteria === "gic") ? { minAlt: 5, minElong: 8, isGIC: true } :
					(criteria === "alt0") ? { minAlt: 0, minElong: -100, isGIC: false } :
					{ minAlt: customMinAlt, minElong: customMinElong, isGIC: false };
				const { minAlt, minElong, isGIC } = criteriaParams;
				const visible = ((!isGIC || sunsetUT < date.ut + 0.5) && moonHor.altitude >= minAlt && elongation >= minElong);
				const visibleStatus = visible ? this.string("visible") : this.string("notVisible");
				const color = visible ? "var(--success)" : "var(--danger)";
				const displayData = [
					{ label: "visibilityStatus", value: visibleStatus, color: color },
					{ label: "sunsetTime", value: formatTime(sunset) },
					{ label: "moonsetTime", value: formatTime(moonset) },
					{ label: "moonAlt", value: moonHor.altitude.toFixed(2) + "°" },
					{ label: "moonElong", value: elongation.toFixed(2) + "°" },
					{ label: "moonAzimuth", value: moonHor.azimuth.toFixed(2) + "°" },
					{ label: "moonAge", value: ageInDays.toFixed(2) + " days" },
					{ label: "illuminatedFraction", value: (moonPhase.phase_fraction * 100).toFixed(2) + "%" }
				];
				let html = "";
				displayData.forEach(item => {
					const style = item.color ? `color: ${item.color};` : "";
					const label = this.string(item.label) || item.label;
					html += `<div class="result-card"><div class="result-label">${label}</div><div class="result-value" style="${style}">${item.value}</div></div>`;
				});
				elements.results.innerHTML = html;
			}

			handleRegionChange() {
				const region = elements.mapRegion.value;

				// Map bounds are 84°N to 84°S, -180° to 180°
				const mapBounds = { minLat: -84, maxLat: 84, minLon: -180, maxLon: 180 };

				if (region === "indonesia") {
					// Indonesia region: -11° to 6° lat, 95° to 141° lon
					const targetBounds = { minLat: -11, maxLat: 6, minLon: 95, maxLon: 141 };
					this.zoomToBounds(targetBounds, mapBounds);
				} else {
					// World view
					this.resetZoom();
				}
			}

			zoomToBounds(targetBounds, mapBounds) {
				const container = elements['map-container'];
				const containerWidth = container.offsetWidth;
				const containerHeight = container.offsetHeight;

				// Calculate how much of the map the target occupies
				const latRange = mapBounds.maxLat - mapBounds.minLat;
				const lonRange = mapBounds.maxLon - mapBounds.minLon;
				const targetLatRange = targetBounds.maxLat - targetBounds.minLat;
				const targetLonRange = targetBounds.maxLon - targetBounds.minLon;

				// Calculate required scale to fit target region
				const scaleX = lonRange / targetLonRange;
				const scaleY = latRange / targetLatRange;
				this.scale = Math.min(scaleX, scaleY, 5); // Cap at max zoom

				// Calculate center of target region in normalized coordinates [0,1]
				const centerLon = (targetBounds.minLon + targetBounds.maxLon) / 2;
				const centerLat = (targetBounds.minLat + targetBounds.maxLat) / 2;

				// Convert to normalized position on map [0,1]
				const normX = (centerLon - mapBounds.minLon) / lonRange;
				const normY = (mapBounds.maxLat - centerLat) / latRange;

				// Calculate translation needed to center this point
				// Since map is centered, we need to offset from center
				this.translateX = -(normX - 0.5) * containerWidth * this.scale;
				this.translateY = -(normY - 0.5) * containerHeight * this.scale;

				this.limitPan();
				this.updateTransform();
			}

			handleRenderClick() {
				this.isRendering ? this.cancelRender() : this.startRender();
			}

			cancelRender() {
				if (this.worker) {
					this.worker.terminate();
					this.worker = null;
				}
				this.isRendering = false;
				elements.renderMap.disabled = false;
				elements.renderMap.textContent = this.string("renderMap");
				elements.mapStatus.textContent = this.string("cancelled");
			}

			startRender() {
				this.isRendering = true;
				elements.renderMap.disabled = false;
				elements.renderMap.textContent = this.string("cancel");
				elements.mapStatus.innerHTML = `<span class="spinner"></span> ${this.string("calculating")}`;

				// Define bounds based on region (image is 84°N to 84°S)
				const region = elements.mapRegion.value;
				let bounds;
				if (region === "indonesia") {
					bounds = { minLat: -11, maxLat: 6, minLon: 95, maxLon: 141 };
				} else {
					bounds = { minLat: -84, maxLat: 84, minLon: -180, maxLon: 180 };
				}

				const criteria = elements.mapCriteria.value;
				const dateString = elements.mapDate.value;
				const dateObj = new Date(dateString ? dateString + "T12:00:00Z" : new Date());
				const widthDeg = bounds.maxLon - bounds.minLon;
				const heightDeg = bounds.maxLat - bounds.minLat;
				this.lastBounds = bounds;

				const renderParams = {
					bounds: bounds,
					widthDeg: widthDeg,
					heightDeg: heightDeg,
					criteria: criteria,
					dateTimestamp: dateObj.getTime(),
					minAlt: parseFloat(elements.minAlt.value) || 0,
					minElong: parseFloat(elements.minElong.value) || 0
				};

				if (!this.worker) {
					const blob = new Blob([WORKER_CODE], { type: 'application/javascript' });
					this.worker = new Worker(URL.createObjectURL(blob));
				}

				this.worker.onmessage = (e) => {
					const data = e.data;
					if (data.progress) {
						elements.mapStatus.innerHTML = `<span class="spinner"></span> ${this.string("calculating")} ${data.progress}%`;
					} else if (data.buffer) {
						this.handleComplete(data.width, data.height, data.buffer);
					} else if (data.error) {
						console.error(data.error);
						elements.mapStatus.textContent = "Error: " + data.error;
						this.cancelRender();
					}
				};
				this.worker.postMessage(renderParams);
			}

			handleComplete(width, height, buffer) {
				const imageData = new ImageData(new Uint8ClampedArray(buffer), width, height);
				this.currentImageData = imageData;
				this.redrawOverlay();
				this.isRendering = false;
				elements.renderMap.disabled = false;
				elements.renderMap.textContent = this.string("renderMap");
				elements.mapStatus.textContent = this.string("done");
			}

			latToMercatorY(lat) {
				const DEG_TO_RAD = Math.PI / 180;
				return Math.log(Math.tan(Math.PI / 4 + (lat * DEG_TO_RAD) / 2));
			}

			redrawOverlay() {
				if (!this.currentImageData || !this.lastBounds) return;
				const canvas = elements['map-overlay'];
				const img = elements['map-image'];

				// Set canvas to match image dimensions
				canvas.width = img.naturalWidth || img.width;
				canvas.height = img.naturalHeight || img.height;

				const ctx = canvas.getContext("2d");
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				// Create temporary canvas with the calculation data
				const tempCanvas = document.createElement('canvas');
				tempCanvas.width = this.currentImageData.width;
				tempCanvas.height = this.currentImageData.height;
				const tempCtx = tempCanvas.getContext('2d');
				tempCtx.putImageData(this.currentImageData, 0, 0);

				// Calculate position based on bounds
				// Image covers 84°N to 84°S, -180° to 180°
				const imgBounds = { minLat: -84, maxLat: 84, minLon: -180, maxLon: 180 };
				const dataBounds = this.lastBounds;

				// Horizontal (Linear)
				const x = ((dataBounds.minLon - imgBounds.minLon) / (imgBounds.maxLon - imgBounds.minLon)) * canvas.width;
				const w = ((dataBounds.maxLon - dataBounds.minLon) / (imgBounds.maxLon - imgBounds.minLon)) * canvas.width;

				// Vertical (Mercator)
				// Map Y=0 is 82°N, Y=Height is -82°S
				const mapTopY = this.latToMercatorY(imgBounds.maxLat);
				const mapBottomY = this.latToMercatorY(imgBounds.minLat);

				const dataTopY = this.latToMercatorY(dataBounds.maxLat);
				const dataBottomY = this.latToMercatorY(dataBounds.minLat);

				// Y pixel is proportional to (mapTopY - val)
				const y = ((mapTopY - dataTopY) / (mapTopY - mapBottomY)) * canvas.height;
				const h = ((mapTopY - dataBottomY) / (mapTopY - mapBottomY)) * canvas.height - y;

				// Draw scaled overlay
				ctx.drawImage(tempCanvas, x, y, w, h);
			}
		}
		new HilalMap();
	</script>
</body>
</html>
